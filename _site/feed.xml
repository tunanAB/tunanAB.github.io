<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://wsttask.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://wsttask.github.io/" rel="alternate" type="text/html" /><updated>2024-02-06T22:20:44+08:00</updated><id>https://wsttask.github.io/feed.xml</id><entry><title type="html">Jekyll</title><link href="https://wsttask.github.io/2024/02/06/jekyll.html" rel="alternate" type="text/html" title="Jekyll" /><published>2024-02-06T20:39:47+08:00</published><updated>2024-02-06T20:39:47+08:00</updated><id>https://wsttask.github.io/2024/02/06/jekyll</id><content type="html" xml:base="https://wsttask.github.io/2024/02/06/jekyll.html"><![CDATA[<pre><code class="language-cmd">//实时渲染网页
//在自动构建过程中对 _config.yml 的修改将不会被包含其中
jekyll server --watch

$ jekyll build
# =&gt; 当前文件夹中的内容将会生成到 ./_site 文件夹中。

$ jekyll build --destination &lt;destination&gt;
# =&gt; 当前文件夹中的内容将会生成到目标文件夹&lt;destination&gt;中。

$ jekyll build --source &lt;source&gt; --destination &lt;destination&gt;
# =&gt; 指定源文件夹&lt;source&gt;中的内容将会生成到目标文件夹&lt;destination&gt;中。

$ jekyll build --watch
# =&gt; 当前文件夹中的内容将会生成到 ./_site 文件夹中，
#    查看改变，并且自动再生成。
</code></pre>]]></content><author><name></name></author><summary type="html"><![CDATA[```cmd //实时渲染网页 //在自动构建过程中对 _config.yml 的修改将不会被包含其中 jekyll server –watch]]></summary></entry><entry><title type="html">Git_command</title><link href="https://wsttask.github.io/2024/02/06/git_command.html" rel="alternate" type="text/html" title="Git_command" /><published>2024-02-06T12:11:26+08:00</published><updated>2024-02-06T12:11:26+08:00</updated><id>https://wsttask.github.io/2024/02/06/git_command</id><content type="html" xml:base="https://wsttask.github.io/2024/02/06/git_command.html"><![CDATA[<h3 id="初始化仓库并与远程仓库建立连接">初始化仓库，并与远程仓库建立连接</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 初始化仓库，无参数代表初始化本目录为仓库
git init &lt;filename&gt;
// 使用 git remote add 命令将本地仓库与远程仓库进行关联，其中 origin 是远程仓库的别名，也可以是其他的名字
git remote add origin https://github.com/xu-xiaoya/Elegent.git
//

</code></pre></div></div>

<h3 id="git-push详解">git push详解</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 命令格式
git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;
// 如果本地分支名与远程分支名相同，则可以省略冒号与远程分支名
git push &lt;远程主机名&gt; &lt;本地分支名&gt;

example:
// 以下命令将本地的 master 分支推送到 origin 主机的 master 分支。
git push origin master

// 如果本地版本与远程版本有差异，但又要强制推送可以使用 <span class="nt">--force</span> 参数：
git push <span class="nt">--force</span> origin master

</code></pre></div></div>

<p><a href="https://blog.csdn.net/Lakers2015/article/details/111318801">git push 的 -u 参数含义_git push -u-CSDN博客</a></p>

<h3 id="git-remote">git remote</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote <span class="nt">-v</span> //查看git对应的远程仓库地址

git remote remove &lt;remote_name&gt;//从当前仓库中删除指定的远程仓库。

git remote <span class="nt">-v</span> //查看是否删除成功，如果没有任何返回结果，表示OK

git remote rename &lt;old_name&gt; &lt;new_name&gt;//将已配置的远程仓库重命名。

git remote add origin https://github.com/<span class="k">***</span>.git //重新关联git远程仓库地址
</code></pre></div></div>

<h3 id="git-substree">git substree</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div>

<h3 id="git-pull">git pull</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[初始化仓库，并与远程仓库建立连接]]></summary></entry><entry><title type="html">Git_gitignore</title><link href="https://wsttask.github.io/2024/02/06/GIT_gitignore.html" rel="alternate" type="text/html" title="Git_gitignore" /><published>2024-02-06T11:53:39+08:00</published><updated>2024-02-06T11:53:39+08:00</updated><id>https://wsttask.github.io/2024/02/06/GIT_gitignore</id><content type="html" xml:base="https://wsttask.github.io/2024/02/06/GIT_gitignore.html"><![CDATA[<p>[<a href="https://zhuanlan.zhihu.com/p/52885189">Git].gitignore文件的配置使用 - 知乎 (zhihu.com)</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[[Git].gitignore文件的配置使用 - 知乎 (zhihu.com)]]></summary></entry><entry><title type="html">Spacedesk</title><link href="https://wsttask.github.io/2024/02/06/spacedesk.html" rel="alternate" type="text/html" title="Spacedesk" /><published>2024-02-06T11:28:09+08:00</published><updated>2024-02-06T11:28:09+08:00</updated><id>https://wsttask.github.io/2024/02/06/spacedesk</id><content type="html" xml:base="https://wsttask.github.io/2024/02/06/spacedesk.html"><![CDATA[<table>
  <tbody>
    <tr>
      <td>[【屏幕扩展】spacedesk vBeta v2.1.0 简单汉化版【12/12更新】 - 『原创发布区』 - 吾爱破解 - LCG - LSG</td>
      <td>安卓破解</td>
      <td>病毒分析</td>
      <td>www.52pojie.cn](https://www.52pojie.cn/thread-1862830-1-1.html)</td>
    </tr>
  </tbody>
</table>

<p>文件保存在 百度网盘的 工具类</p>

<p><a href="https://blog.csdn.net/tfnmdmx/article/details/126084099">spacedesk-笔记本、平板、扩展屏幕-解决平板字体太小的问题_spacedesk 网页端拓展屏幕-CSDN博客</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[[【屏幕扩展】spacedesk vBeta v2.1.0 简单汉化版【12/12更新】 - 『原创发布区』 - 吾爱破解 - LCG - LSG 安卓破解 病毒分析 www.52pojie.cn](https://www.52pojie.cn/thread-1862830-1-1.html)]]></summary></entry><entry><title type="html">Git_升级版本</title><link href="https://wsttask.github.io/2024/02/06/GIT_%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC.html" rel="alternate" type="text/html" title="Git_升级版本" /><published>2024-02-06T09:26:22+08:00</published><updated>2024-02-06T09:26:22+08:00</updated><id>https://wsttask.github.io/2024/02/06/GIT_%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC</id><content type="html" xml:base="https://wsttask.github.io/2024/02/06/GIT_%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC.html"><![CDATA[<p><a href="https://blog.csdn.net/yuwentao4761901/article/details/107858129">升级Git版本到最新的方法_git 版本升级git-2.34.5-CSDN博客</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[升级Git版本到最新的方法_git 版本升级git-2.34.5-CSDN博客]]></summary></entry><entry><title type="html">Git</title><link href="https://wsttask.github.io/2024/02/06/git.html" rel="alternate" type="text/html" title="Git" /><published>2024-02-06T09:20:19+08:00</published><updated>2024-02-06T09:20:19+08:00</updated><id>https://wsttask.github.io/2024/02/06/git</id><content type="html" xml:base="https://wsttask.github.io/2024/02/06/git.html"><![CDATA[<h4 id="git-常用命令">git 常用命令</h4>

<blockquote>
  <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看git所有配置</span>
<span class="nv">$ </span>git config <span class="nt">-l</span>

<span class="c"># 查看系统的配置，其中--system是筛选条件   </span>
<span class="nv">$ </span>git config <span class="nt">--system</span> <span class="nt">--list</span>   、Git<span class="se">\e</span>tc<span class="se">\g</span>itconfig:Git安装目录下的 gitconfig <span class="nt">--system</span> 系统级

<span class="c"># 查看缓存大小</span>
<span class="nv">$ </span>git config <span class="nt">--get</span> http.postBuffer 

<span class="c"># 重新设置缓存大小为1024M</span>
<span class="nv">$ </span>git config <span class="nt">--global</span> http.postBuffer 1024M 

<span class="c"># 查看个人的配置</span>
<span class="nv">$ </span>git config <span class="nt">--global</span> <span class="nt">--list</span>     、C:<span class="se">\U</span>sers<span class="se">\A</span>dministrator<span class="se">\ </span>.gitconfig   只适用于当前登录用户的配置  <span class="nt">--global</span> 全局

<span class="c"># 配置user.name</span>
<span class="nv">$ </span>git config <span class="nt">--global</span> user.name <span class="s2">"Sheng"</span> 

<span class="c"># 配置user.email</span>
<span class="nv">$ </span>git config <span class="nt">--global</span> user.email <span class="s2">"704341315@qq.com"</span> 

<span class="o">(</span>所有的配置，都是以文件形式保存在本地文件中<span class="o">)</span> 
注意：git config <span class="nt">--global</span> 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。

<span class="c"># 克隆远程仓库</span>
<span class="nv">$ </span>git clone <span class="s2">"adress"</span> 
注意文件名中不能包含 <span class="se">\ </span>/ : <span class="k">*</span> ? <span class="s2">" &lt; &gt; ||

# 在当前目录新建一个Git代码库
</span><span class="nv">$ </span><span class="s2">git init 

# 查看指定文件状态
</span><span class="nv">$ </span><span class="s2">git status [filename]

#查看所有文件状态
</span><span class="nv">$ </span><span class="s2">git status 

# 添加所有文件到暂存区
</span><span class="nv">$ </span><span class="s2">git add . 

# 提交暂存区中的内容到本地仓库 -m 提交信息
</span><span class="nv">$ </span><span class="s2">git commit -m "</span>消息内容<span class="s2">"    

# 把repository中的内容提交到远程仓库
</span><span class="nv">$ </span><span class="s2">git push 

# 返回上一次修改
</span><span class="nv">$ </span><span class="s2">git reset --hard HEAD^

# 返回该版本，直接更改workspace中的内容
</span><span class="nv">$ </span><span class="s2">git reset --hard  [版本号]

# 不加参数即默认比较工作区与暂存区
</span><span class="nv">$ </span><span class="s2">git diff [file] 
注意只能比较index和workspace中已有文件的差异，如果workspace中新增加了一个文件，那么就比较不出来这个文件

# 显示工作目录与当前git仓库之间的差异
</span><span class="nv">$ </span><span class="s2">git diff HEAD 

# 显示工作目录与上一个版本git仓库之间的差异，或者可以说是git pull 之后查看修改
</span><span class="nv">$ </span><span class="s2">git diff HEAD^

# 查看日志
</span><span class="nv">$ </span><span class="s2">git log

# 查看日志
</span><span class="nv">$ </span><span class="s2">git reflog 

# 可以丢弃工作区的修改，在index区进行检索file文件
</span><span class="nv">$ </span><span class="s2">git checkout -- file

1.readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。
2.另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态
3.可以恢复在工作区误删的文件file，只要repository区中有

# 列出所有本地分支
</span><span class="nv">$ </span><span class="s2">git branch

# 列出所有远程分支
</span><span class="nv">$ </span><span class="s2">git branch -r

# 列出所有本地分支和远程分支
</span><span class="nv">$ </span><span class="s2">git branch -a

# 新建一个分支，但依然停留在当前分支
</span><span class="nv">$ </span><span class="s2">git branch [branch-name]

# 新建一个分支，并切换到该分支
</span><span class="nv">$ </span><span class="s2">git checkout -b [branch]

# 新建一个分支，指向指定commit
</span><span class="nv">$ </span><span class="s2">git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
</span><span class="nv">$ </span><span class="s2">git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
</span><span class="nv">$ </span><span class="s2">git checkout [branch-name]

# 切换到上一个分支
</span><span class="nv">$ </span><span class="s2">git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
</span><span class="nv">$ </span><span class="s2">git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
</span><span class="nv">$ </span><span class="s2">git merge [branch]

# 选择一个commit，合并进当前分支
</span><span class="nv">$ </span><span class="s2">git cherry-pick [commit]

# 删除分支
</span><span class="nv">$ </span><span class="s2">git branch -d [branch-name]

# 删除远程分支
</span><span class="nv">$ </span><span class="s2">git push origin --delete [branch-name]
</span><span class="nv">$ </span><span class="s2">git branch -dr [remote/branch]


# 展示当前关联的其他仓库列表
</span><span class="nv">$ </span><span class="s2">git remote -v 
</span></code></pre></div>  </div>
</blockquote>

<h3 id="关于git-pull">关于git pull</h3>

<p>git pull 会自动和本地提交合并，与本地有冲突时需要手动合并。</p>

<p>未提交本地代码进行 git pull 时，会提示异常提醒先 commit 后再进行 pull</p>

<p>也就是说，如果git pull拉下来的改变，你没有修改，就不会提示异常，</p>

<p><code class="language-plaintext highlighter-rouge">git pull</code>实际上是<code class="language-plaintext highlighter-rouge">git fetch</code>和<code class="language-plaintext highlighter-rouge">git merge</code>两个命令的组合，它从远程仓库获取最新的代码并自动合并到当前分支。</p>

<h3 id="git合并分支的具体步骤如下">Git合并分支的具体步骤如下：</h3>

<p>确认当前分支的状态：在执行合并分支命令之前，我们需要确认当前分支的状态，即是否有未提交的修改。可以通过git status命令查看当前分支的状态。</p>

<p>切换到要合并的分支：使用git checkout命令切换到要合并的分支，具体语法是git checkout <branch-name>，其中<branch-name>表示要合并的分支名。</branch-name></branch-name></p>

<p>合并分支：使用git merge命令合并分支，具体语法是git merge <branch-to-merge>，其中<branch-to-merge>表示要合并的分支名。</branch-to-merge></branch-to-merge></p>

<p>处理合并冲突：如果合并过程中存在冲突，需要手动解决冲突并提交代码。</p>

<p>确认合并结果：合并完成后，我们需要确认合并后分支的状态是否正确。可以使用git log命令查看分支的提交记录，或者使用git diff命令比较合并前后代码的差异。</p>

<p><strong>底层原理如下</strong></p>

<p>​	Git在底层存储时，使用了一种名为”commit graph”的数据结构来管理提交记录，该数据结构可以看作是一个<strong>有向无环图</strong>(DAG)，其中每个节点表示一个提交记录，每条有向边表示一个提交记录的父节点。在Git中，合并分支实际上是将两个分支的提交记录合并到一起，创建一个新的提交记录。合并分支的过程中，Git会执行以下操作：</p>

<p>​	找到两个分支最近的共同祖先：在合并分支前，Git会找到两个分支最近的共同祖先，这个祖先节点是合并操作的基础。</p>

<p>​	创建一个新的提交记录：Git会在共同祖先的基础上创建一个新的提交记录，该记录包含合并前两个分支的所有修改内容。这个新的提交记录将成为合并后分支的最新提交记录。</p>

<p>​	解决冲突：如果合并过程中存在冲突，Git会暂停合并操作，并让用户手动解决冲突。解决冲突后，用户需要使用git add命令将修改内容标记为已解决，然后使用git commit命令提交代码。</p>

<p>​	更新分支指针：合并完成后，Git会更新当前分支的指针，指向合并后的最新提交记录。同时，如果存在其他分支指针指向合并前的某个提交记录，也会被更新到指向合并后的最新提交记录。</p>]]></content><author><name></name></author><summary type="html"><![CDATA[git 常用命令]]></summary></entry><entry><title type="html">copy命令</title><link href="https://wsttask.github.io/bat/2024/02/06/copy.html" rel="alternate" type="text/html" title="copy命令" /><published>2024-02-06T00:00:00+08:00</published><updated>2024-02-06T00:00:00+08:00</updated><id>https://wsttask.github.io/bat/2024/02/06/copy</id><content type="html" xml:base="https://wsttask.github.io/bat/2024/02/06/copy.html"><![CDATA[<pre><code class="language-cmd">copy &lt;源文件&gt; &lt;目标文件夹/没有默认是当前目录&gt;
/? 查看帮助
</code></pre>]]></content><author><name></name></author><category term="bat" /><summary type="html"><![CDATA[copy &lt;源文件&gt; &lt;目标文件夹/没有默认是当前目录&gt; /? 查看帮助]]></summary></entry><entry><title type="html">Vpn</title><link href="https://wsttask.github.io/2024/02/05/vpn.html" rel="alternate" type="text/html" title="Vpn" /><published>2024-02-05T20:22:09+08:00</published><updated>2024-02-05T20:22:09+08:00</updated><id>https://wsttask.github.io/2024/02/05/vpn</id><content type="html" xml:base="https://wsttask.github.io/2024/02/05/vpn.html"><![CDATA[<p>https://ikuuu.org/auth/login</p>

<p><a href="https://sockboom.link/user/">sockboom.link</a></p>

<p><a href="https://sockboom.buzz/user/">SockBoom</a></p>

<p>sockboom域名更新了</p>

<p>ilink	这个是edge的扩展</p>]]></content><author><name></name></author><summary type="html"><![CDATA[https://ikuuu.org/auth/login]]></summary></entry><entry><title type="html">Websites</title><link href="https://wsttask.github.io/2024/02/05/websites.html" rel="alternate" type="text/html" title="Websites" /><published>2024-02-05T20:21:54+08:00</published><updated>2024-02-05T20:21:54+08:00</updated><id>https://wsttask.github.io/2024/02/05/websites</id><content type="html" xml:base="https://wsttask.github.io/2024/02/05/websites.html"><![CDATA[<p><a href="https://www.axutongxue.top/">万事屋的阿虚 (axutongxue.top)</a></p>

<p><a href="https://www.toolhelper.cn/EncodeDecode/UnicodeChineseEncodeDecode">符号与unicode转换</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[万事屋的阿虚 (axutongxue.top)]]></summary></entry><entry><title type="html">markdown语法手册</title><link href="https://wsttask.github.io/markdown/2024/02/05/Markdown.html" rel="alternate" type="text/html" title="markdown语法手册" /><published>2024-02-05T00:00:00+08:00</published><updated>2024-02-05T00:00:00+08:00</updated><id>https://wsttask.github.io/markdown/2024/02/05/Markdown</id><content type="html" xml:base="https://wsttask.github.io/markdown/2024/02/05/Markdown.html"><![CDATA[<h3 id="1-斜体和粗体">1. 斜体和粗体</h3>

<p>代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*斜体*或_斜体_
**粗体**
***加粗斜体***
~~删除线~~
</code></pre></div></div>

<p>显示效果：</p>

<ul>
  <li><em>这是一段斜体</em></li>
  <li><strong>这是一段粗体</strong></li>
  <li><strong><em>这是一段加粗斜体</em></strong></li>
  <li><del>这是一段删除线</del></li>
</ul>

<h3 id="2-分级标题">2. 分级标题</h3>
<p>第一种写法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>这是一个一级标题
============================
这是一个二级标题
--------------------------------------------------
</code></pre></div></div>

<p>第二种写法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
</code></pre></div></div>

<p>由于用了[TOC]标记编辑器会把所有标题写到目录大纲中，在这里写的演示标题也会列进去，所以就不演示了。同学们自己在编辑器中观察，很简单，一级标题字号最大，依级递减。</p>

<h3 id="3-超链接">3. 超链接</h3>
<p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。</p>

<h4 id="31-行内式">3.1. 行内式</h4>
<p>语法说明：</p>
<ul>
  <li>[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。<a href="链接地址 “链接标题”">链接文字</a>’这样的形式。链接地址与链接标题前有一个空格。</li>
</ul>

<p>代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>欢迎来到[梵居闹市](http://blog.leanote.com/freewalk)
欢迎来到[梵居闹市](http://blog.leanote.com/freewalk "梵居闹市")

</code></pre></div></div>

<p>显示效果：</p>

<p>欢迎来到<a href="http://blog.leanote.com/freewalk">梵居闹市</a></p>

<p>欢迎来到<a href="http://blog.leanote.com/freewalk" title="梵居闹市">梵居闹市</a></p>

<h3 id="4-锚点">4. 锚点</h3>
<p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。</p>

<p>注意：</p>
<ol>
  <li>Markdown Extra 只支持在标题后插入锚点，其它地方无效。</li>
  <li>Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。</li>
</ol>

<p>语法描述：</p>

<p>在你准备跳转到的指定标题后插入锚点{#标记}，然后在文档的其它地方写上连接到锚点的链接。</p>

<p>代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.## 0. 目录{#index}
2.
3.跳转到[目录](#index)
</code></pre></div></div>

<h3 id="5-列表">5. 列表</h3>

<h4 id="51-无序列表">5.1. 无序列表</h4>

<p>使用 *，+，- 表示无序列表。</p>

<p>代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 无序列表项 一
- 无序列表项 二
- 无序列表项 三
</code></pre></div></div>

<p>显示效果：</p>

<ul>
  <li>无序列表项 一</li>
  <li>无序列表项 二</li>
  <li>无序列表项 三</li>
</ul>

<h4 id="52-有序列表">5.2. 有序列表</h4>

<p>有序列表则使用数字接着一个英文句点。</p>

<p>代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 有序列表项 一
2. 有序列表项 二
3. 有序列表项 三
</code></pre></div></div>

<p>显示效果：</p>

<ol>
  <li>有序列表项 一</li>
  <li>有序列表项 二</li>
  <li>有序列表项 三</li>
</ol>

<h3 id="6-引用">6. 引用</h3>

<p>语法说明：</p>

<p>引用需要在被引用的文本前加上&gt;符号。</p>

<p>代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 这是一个有两段文字的引用,
&gt; 无意义的占行文字1.
&gt; 无意义的占行文字2.
&gt; 
&gt; 无意义的占行文字3.
&gt; 无意义的占行文字4.
</code></pre></div></div>

<p>显示效果：</p>

<blockquote>
  <p>这是一个有两段文字的引用,
无意义的占行文字1.
无意义的占行文字2.</p>

  <p>无意义的占行文字3.
无意义的占行文字4.</p>
</blockquote>

<p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ：</p>

<p>代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 这是一个有两段文字的引用,
无意义的占行文字1.
无意义的占行文字2.
&gt; 无意义的占行文字3.
无意义的占行文字4.
</code></pre></div></div>

<p>显示效果：</p>

<blockquote>
  <p>这是一个有两段文字的引用,
无意义的占行文字1.
无意义的占行文字2.
无意义的占行文字3.
无意义的占行文字4.</p>
</blockquote>

<h3 id="7-插入图像">7. 插入图像</h3>

<p>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。</p>

<p>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p>

<h4 id="71-行内式">7.1. 行内式</h4>

<p>语法说明：<img src="图片地址 “图片Title”" alt="图片Alt" /></p>

<p>代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
1. 美丽花儿： 
2. ![美丽花儿](http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg "美丽花儿")
</code></pre></div></div>

<p>显示效果：</p>

<p>美丽花儿：</p>

<h4 id="72-参考式">7.2. 参考式</h4>
<p>语法说明：</p>

<p>在文档要插入图片的地方写![图片Alt][标记]</p>

<p>在文档的最后写上[标记]:图片地址 “Title”</p>

<p>代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 美丽花儿：
2. ![美丽花儿][flower]
3. 
4. [flower]:http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg  "美丽花儿"
</code></pre></div></div>

<p>显示效果：</p>

<p>美丽花儿：</p>

<h3 id="8-代码">8. 代码</h3>

<p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用`符号（一般在ESC键下方）包裹代码。</p>

<p>语法说明：</p>

<p>插入行内代码，即插入一个单词或者一句代码的情况，使用<code class="language-plaintext highlighter-rouge">code</code>这样的形式插入。</p>

<p>插入多行代码，可以使用缩进或者```,具体看示例。</p>

<p>注意： 缩进式插入前方必须有空行</p>

<h4 id="81-行内式">8.1. 行内式</h4>
<p>代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C语言里的函数 `scanf()` 怎么使用？
</code></pre></div></div>
<p>显示效果：</p>

<p>C语言里的函数 <code class="language-plaintext highlighter-rouge">scanf()</code> 怎么使用？</p>

<h4 id="82-缩进式多行代码">8.2. 缩进式多行代码</h4>
<p>缩进 4 个空格或是 1 个制表符</p>

<p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>

<p>代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #include &lt;stdio.h&gt;
    int main(void)
    {
        printf("Hello world\n");
    }

</code></pre></div></div>

<p>显示效果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
int main(void)
{
    printf("Hello world\n");
}
</code></pre></div></div>

<p>8.3. 用六个`包裹多行代码
代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\```
#include &lt;stdio.h&gt;
int main(void)
{
    printf("Hello world\n");
}
\```
</code></pre></div></div>

<p>显示效果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
int main(void)
{
    printf("Hello world\n");
}
</code></pre></div></div>]]></content><author><name></name></author><category term="markdown" /><summary type="html"><![CDATA[1. 斜体和粗体]]></summary></entry></feed>