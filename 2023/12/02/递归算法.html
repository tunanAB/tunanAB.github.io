<p>程序直接或间接的调用自身的编程技巧称为递归算法，直接或间接调用自身的函数称为递归函数；
它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。</p>

<p>递归问题基本思想：问题层层分析</p>

<p>关键：找出递归定义和递归终止条件</p>

<p>递归定义：使问题向边界条件转化的规则</p>

<p>递归终止条件：所描述问题的最简单的情况，它本身不再使用递归的定义</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">例：求</span><span class="mi">1</span><span class="o">~</span><span class="mi">100</span><span class="err">的和</span>
<span class="err">递归</span> <span class="n">fn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">=</span><span class="n">n</span><span class="o">+</span><span class="n">fn</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="err">终止条件：</span><span class="n">fn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="mi">1</span>
<span class="err">代码：</span>
<span class="n">function</span> <span class="nf">fn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">Return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> 
        <span class="k">return</span> <span class="n">n</span><span class="o">+</span><span class="n">fn</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="err">例：求最大公因式（欧几里得算法）</span>
<span class="err">递归：</span> <span class="n">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="o">=</span><span class="n">gcd</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="o">%</span><span class="n">n</span><span class="p">)</span>
<span class="err">终止条件：</span><span class="n">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">=</span><span class="n">m</span>
<span class="err">代码：</span>
<span class="n">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">If</span><span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="k">else</span> 
        <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="o">%</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>递归总结
通过递归调用将整个问题层层分解成处理方法相似的子问题；
通过回溯，按照递归关系将子问题的解整理成整个问题的解；
分解子问题时，如果当前问题有多种情况需要考虑，要逐一进行枚举；</p>

<p>通过上面的分析，是不是感觉递归很简单。所以我们写递归的时候完全可以套用上面的模板，
先写出终止条件，然后在写递归的逻辑调用。还有一点非常重要，就是一定要明白递归函数中每个参数的含义，
这样在逻辑处理和函数调用的时候才能得心应手，函数的调用我们一定不要去一步步拆开去想，这样很有可能你会奔溃的。</p>
