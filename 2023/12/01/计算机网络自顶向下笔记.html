<h3 id="第一章-计算机网络与因特网">第一章 计算机网络与因特网</h3>

<p>概括：由通信链路和分组交换机连接巨大数量的端系统构成的巨大转发网络</p>

<p>构成：</p>

<ul>
  <li>
    <p>主机（host）= 端系统（end system）：接入计算机网络的智能设备，个人电脑、智能家电等；又根据功能大致分为客户（client）、服务器（server）</p>
  </li>
  <li>
    <p>通信链路（communication link）：连接网络的线路—实体到实体的一条链路构成路径（path/route）</p>
  </li>
  <li>
    <p>分组交换机（packet switch）：路由器（router）（圆形X表示）和链路交换机（switch）（方块X表示）</p>
  </li>
  <li>
    <p>服务提供商（Internet Service Provider，ISP）：提供接入网络的服务，比如三大运营商等</p>
  </li>
  <li>
    <p>因特网工程任务组（Internet Engineering Task Force，IETF）：负责因特网协议和规范的制订，制订文件统一为RFC（Request For Comment）+编号</p>
  </li>
  <li>
    <p>分组概念（packet）：发送端将长信息截断打包</p>
  </li>
  <li>
    <p>传输速率（Transmission Rate）：特指将数据搬移到链路的转化速度（bps），注意与传播速率（Propagation rate）区分</p>
  </li>
</ul>

<h4 id="12-网络边缘">1.2 网络边缘</h4>

<ul>
  <li>边缘路由（edge router）：负责将<strong>端系统</strong>接入网络的第一个路由器</li>
  <li>边缘组：由主机/端系统+接入网构成（家庭组、企业组等）</li>
</ul>

<ol>
  <li>家庭接入：DSL，电缆，FTTH，拨号和卫星</li>
</ol>

<ul>
  <li>FTTH（Filber To The Home）：光纤到户</li>
  <li>DSL（Digital Subscriber Line）：数据用户线</li>
  <li>CIC（Cable Internet Access）电缆因特网接入</li>
</ul>

<h5 id="122-物理媒介">1.2.2 物理媒介</h5>

<ul>
  <li>双绞线</li>
</ul>

<p>最便宜的引导性传输媒体，由两条相互螺旋缠绕的铜线组成。目前局域网中的双绞线数据传输速率在10Mbps到10Gbps之间，所能达到的数据传输速率取决于线的粗细以及传输距离；双绞线实际上已经成为高速局域网联网的主要方式；因为现代的双绞线技术速率和传输距离都是很不错的；</p>

<ul>
  <li>同轴电缆</li>
</ul>

<p>也由两个铜导体构成，但是它们是同心的，而非并行的；借助特殊的结构和绝缘层，同轴电缆可得到较高的数据传输速率；在电视系统中应用广泛；同轴电缆可被用作引导性的共享媒体；</p>

<ul>
  <li>光纤</li>
</ul>

<p>一种可以引导光脉冲的媒体</p>

<ul>
  <li>陆地无线电信道</li>
</ul>

<p>无线电信道承载电磁频谱中的信号，不需要物理线路，提供与移动用户的连接以及长距离承载信号的方式；是一种有吸引力的媒体；</p>

<ul>
  <li>卫星无线电信道</li>
</ul>

<p>通过卫星连接两个或多个在地球上的微波发射方（也被称为地面站），该卫星在一个频段上接收信号，在另一个频段上发送信号；种类有同步卫星和近地轨道卫星；</p>

<h4 id="13-网络核心">1.3 网络核心</h4>

<p>网络核心即为由互联端系统的分组交换机和链路构成的网状网络, 网络核心的关键功能: <strong>路由</strong>+<strong>转发</strong></p>

<p>通过网络链路和交换机移动数据有两种基本方法：电路交换和分组交换</p>

<h5 id="131-分组交换">1.3.1 分组交换</h5>

<p>分组在通信链路上以等于该链路的最大传输速率传输通过通信链路。因此如果某条链路的最大传输速率为R，分组长度为L，则该链路传输该分组的时间为L/R；这个时间也被称为传输时延；分组交换的常见方式是存储转发机制；</p>

<p>分组：报文分拆出来的一系列相对较小的数据包，分组交换需要报文的拆分与重组，会产生额外开销</p>

<ol>
  <li><strong>存储转发时延</strong></li>
</ol>

<p>大多数分组交换机采用存储转发机制来转发分组；所谓存储转发是指交换机在收到一个完成的分组，才会向链路输出转发分组，否则就将收到的部分分组缓存起来；因为缓存等待一个分组的全部数据而导致的时间开销被称为存储转发时延</p>

<ol>
  <li><strong>排队时延与分组丢失</strong></li>
</ol>

<p>因为需要缓存分组，所以此时分组交换机需要一个输出缓存和输出队列；缓冲队列的空间有限性就有可能导致分组交换机无法继续缓存分组（因为链路被占用或者分组还没全部到位）而使到达分组交换机的数据包被迫丢弃；这就导致了分组不但承担了传输时延，还承担了队列时延。</p>

<ol>
  <li><strong>转发表与路由选择协议</strong></li>
</ol>

<p>实际上，分组交换机之所以能够知道往哪去是因为其内部有一个<strong>转发表</strong>，这个表维护了一个IP地址和链路的对应关系，所以处理流程为：</p>

<ol>
  <li>通过分组的必要信息，获得目的端系统的IP地址</li>
  <li>通过IP地址索引转发表，从而确定输出链路</li>
</ol>

<h5 id="132-电路交换">1.3.2 电路交换</h5>

<p>在电路交换网络中，在端系统通信会话期间，交换机会预留端系统间通信路径上的相关资源（缓存，链路传输速率），即先建立连接，然后通信，独占资源；而在分组交换网络中，这些资源没有被预留；也就是说，在端系统进行通信时，其所需要的资源是被保持的，其他通信是无法使用这一部分资源的；也就说，端系统间真正建立了一条“连接”；而这一连接，用电话的术语被称为“电路”。传统的电话网络就是电路交换网络的例子。</p>

<ol>
  <li>电路交换中的复用</li>
</ol>

<ul>
  <li><strong>时分复用</strong>（Time-Division Multiplexing TDM）：是指将时间划分为固定区间的<strong>帧</strong>，每个帧则又被划分为固定数量的时间<strong>空隙</strong>；当网络需要建立一条连接时，网络将在每个帧中为该连接指定一个时隙；在该时隙内，链路用来传输该链接的数据；</li>
  <li><strong>频分复用</strong>(Frequency-Division Multiplexing)：将频率域划分为频段，然后将频段分配给连接；此频段被用来专门传输链接的数据。该频段的宽度成为带宽。</li>
  <li>除此之外，多路复用技术还有<strong>波分多路复用</strong>(Wavelength division multiplexing-WDM)和和<strong>码分多路复用</strong>( Code division multiplexing-CDM)，波分复用就是光的频分复用</li>
</ul>

<p>数据交换除了电路交换和分组交换，还有一种书上未介绍的<strong>报文交换</strong>，<strong>报文</strong>：源（应用）发送信息整体，比如一个文件，作为整体进行发送。</p>

<p>报文交换与分组交换均采用存储-转发交换方式，区别：</p>

<ul>
  <li>报文交换以<strong>完整报文</strong>进行“存储-转发”</li>
  <li>分组交换以<strong>较小的分组</strong>进行“存储-转发”</li>
</ul>

<h5 id="133-网络的网络">1.3.3 网络的网络</h5>

<p><img src="../images/adsf.png" alt="img" /></p>

<p>总体来说，今天的因特网是一个“网络的网络”，其结构复杂，由十多个顶层ISP和数十万个较低层ISP构成。近年来，主要的内容提供商创建自己的网络，直接在可能的地方与较低层ISP互联</p>

<h4 id="14-分组交换网中的时延丢包和吞吐量">1.4 分组交换网中的时延、丢包和吞吐量</h4>

<h5 id="141-分组交换网中的时延概述">1.4.1 分组交换网中的时延概述</h5>

<p>（1）处理时延（nodal processing delay）</p>

<p>处理时延是因为节点需要解析分组的必要信息然后决定其出链路（索引转发表等操作）而产生的，通常在微秒或者更低数量级；</p>

<p>（2）排队时延（queueing delay）</p>

<p>排队时延是因为分组所对应的出链路前面有其他分组正在传输，所以分组需要该链路的缓冲队列里等待其他分组传输完毕而产生的；一般来说，排队时延是到达该队列的流量强度和性质的函数，通常可以达到毫秒级到微秒级；</p>

<p>（3）传输时延（transmission delay）</p>

<p>传输时延是将<strong>所有分组的比特推向链路所有需要的时间</strong>，实际的传输时延通常在毫秒到微秒数量级。用L表示分组的长度，用Rbps表示从路由器A到B的链路传输速率。传输时延是L/R。</p>

<p>dtrans = L/R，其中 L 是分组长度(bits)，R 是链路带宽 (bps)</p>

<p>（4）传播时延（propagation delay）</p>

<p>传播时延是指<strong>比特进入链路后，从该链路的起点到下一个结点所用的时间</strong>；一旦分组中的最后一个比特到达路由器就意味着该分组的所有比特都已到达路由器；广域网中，传播时延一般是毫秒级的。传播时延是d/s。d是路由器A到B的距离。s是链路的传播速率。</p>

<p>dprop = d/s，其中 d 是物理链路长度，s 是信号传播速度 (~2×10 8m/sec)</p>

<h5 id="142-排队时延和丢包">1.4.2 排队时延和丢包</h5>

<p>丢包：到达的分组发现一个满的队列。由于没有地方存储这个分组，路由器将丢弃该分组，该分组将会丢失</p>

<p>排队时延和丢包与网络的状况和结点的缓冲空间大小、处理速度相关；如果分组到达的速度高于结点的处理速度，那么分组就会在缓冲队列里排队等待。当缓冲空间用完后，如果还有到的分组，那么该分组将被迫丢弃</p>

<p>为了描述网络状体，我们引入了流量强度这一概念：流量强度=分组到达的速度/结点的处理速度；流量工程里一个金科玉律就是：设计系统时流量强度不能大于1；</p>

<p>当流量强度持续大于1时，就将出现丢包现象</p>

<h5 id="143-端到端时延">1.4.3 端到端时延</h5>

<p>假定从源主机到目的主机之间有 N-1 台路由器，并且无排队现象</p>

<p>$d_{end-end}=N(d_{proc}+d_{trans}+d_{prop})$</p>

<h5 id="144-计算机网络的吞吐量">1.4.4 计算机网络的吞吐量</h5>

<p>计算机网络的吞吐量实际上是一个速度指标，它描述了比特经过某个节点的速度。对于某条路径上的结点来说，和该结点有关的速度有两个：接收数据的速度和发送数据的速度，而该结点的吞吐量是这两个速度中较小的一个；对于某条路径来说，该路径的吞吐量则是所有节点的吞吐量的最小值；网络的吞吐量可以衡量网络的性能.</p>

<p>任何时间的<strong>瞬时吞吐量</strong>是主机B接受到该文件的速率</p>

<p>如果该文件由F比特组成，主机B接受到所有比特用去Ts，则文件的<strong>平均吞吐量</strong>为F/Tbps</p>

<p>吞吐量可以近似为源和目的地之间路径的最小传输速率。最小传输速率的链路为<strong>瓶颈链路</strong>。</p>

<p>在今天，因特网对吞吐率的限制因素通常是接入网。</p>

<h4 id="15-协议层次及其服务模型">1.5 协议层次及其服务模型</h4>

<h5 id="151-分层体系结构">1.5.1 分层体系结构</h5>

<p>总体来说，将各层的所有协议组合起来，称为协议栈。因特网的协议栈有5个层次组成：物理层、链路层、网络成、传输层、应用层</p>

<ul>
  <li>
    <p>应用层：应用层协议分布在多个端系统，端系统中的应用程序使用该协议与另一个端系统中的应用程序通信。处于应用层的分组称为报文；</p>
  </li>
  <li>
    <p>传输层：传输层在应用程序端点之间传输应用层报文，因特网中有两个传输层协议：TCP和UDP。处于传输层的分组称为报文段。TCP提供确保传递、流量控制、拥塞控制机制。UDP提供无连接服务，即不提供不必要服务的服务。没有可靠性、没有流量和拥塞控制。</p>
  </li>
  <li>
    <p>网络层：网络层将称为数据报的网络层分组从一台主机移动到另一台主机。网络层协议包含著名的IP协议以及其他一些路由选择协议。数据报</p>
  </li>
  <li>
    <p>链路层：链路层将称为帧的链路层分组从一个结点移动到路径上的另一个端点。一个帧可能被沿途不同链路上的不同链路层协议处理。帧</p>
  </li>
  <li>
    <p>物理层：物理层的任务是将帧中的比特从一个结点移动到下一个节点，它提供了传输信息的实际物理通道；</p>
  </li>
</ul>

<p>在因特网协议栈出现以前，OSI模型是ISO组织研发的计算机网络结构模型。OSI的模型一共有7层，从下到上依次为：物理层，链路层，网络层，传输层，<strong>会话层，表示层</strong>，应用层。相比因特网体系结构，OSI多了两层。</p>

<p>因特网将两层的功能留给了开发者自行实现。</p>

<h5 id="152-封装">1.5.2 封装</h5>

<p>一个分组，在不同的层次有不同的称谓，是因为它们经过每一层的时候就被该层封装上了属于该层的相关信息，也就是前面提到的必要信息；于是，每一分层的分组有两种类型的字段：首部字段和有效负载；其中有效负载即为来自上一层的分组数据，而首部字段就是该层加上的必要信息；分组不断被封装以实现各层协议规定的相关功能</p>

<p>封装增加控制信息，构造协议数据单元 (PDU)；控制信息主要包括：地址，差错检测编码（Error-detecting code），协议控制（Protocol control），协议控制实现协议功能的附加信息，如: 优先级（priority）、服务质量（QoS）、 和安全控制等</p>

<p><img src="../images/asdfsasf" alt="在这里插入图片描述" /></p>

<h3 id="第二章-应用层">第二章 应用层</h3>

<h5 id="211-网络应用程序体系结构">2.1.1 网络应用程序体系结构</h5>

<ul>
  <li>客户-服务器体系结构</li>
</ul>

<p>在该体系结构中，有一个总是打开的主机，即服务器，它接收和服务来自其他许多被称为客户的主机请求；值得注意的是，在该体系结构中，客户之间是不直接通信的；该服务器具有固定的、周知的地址</p>

<p>客户-服务器体系结构的著名应用有：Web、FTP、Telnet和电子邮件。</p>

<p>通常，如果仅有一台服务器处理所有的请求，那么服务器系统将很快变得不堪重负，为此，配备大量主机的数据中心常被用于创建强大的虚拟的服务器，一个数据中心可以有数十万台服务器，它们需要供电和维护，同时服务提供商还需要支付不断出现的互联和带宽费用，以及发送和接收到达/来自数据中心的数据；</p>

<ul>
  <li>P2P体系结构</li>
</ul>

<p>在P2P体系结构中，对位于数据中心的专用服务器有着最小（或者没有）依赖。应用程序在间断连接的主机对之间使用直接通信，这些主机被称为对等方。对等方并不为服务提供商所拥有，因为这种对等方通信不需要通过专门的服务器，所以该体系结构也被称为对等方到对等方结构</p>

<p>目前，流量密集型应用都是P2P体系结构的。这些应用包括文件共享（例如BitTorrent）、协助下载（例如迅雷）、因特网电话（例如Skype）和IPTV(例如迅雷看看)。</p>

<p>值得注意的是，某些应用具有混合的体系结构，它们结合了客户-服务器和P2P这两种体系结果，比如许多的即时通讯工具，服务器用来跟踪用户IP地址，但是用户之间的通信则使用直接发送</p>

<p>P2P体系结构最引人入胜的特性之一就是它们的自扩展性。比如在文件共享应用中，对等方可能通过向文件的原始拥有者发出请求而产生工作量，但是对等方也有可能通过为其他对等方传送文件而为原始拥有者分担压力；P2P体系结构也是成本有效的，因为他通常不需要庞大的服务器基础设施和服务带宽。</p>

<p>但是P2P也面临着以下三个问题：</p>

<ul>
  <li>
    <p>ISP友好。大多数住宅ISP受制于非对称带宽应用，也就是下载比上传要多得多。但是P2P视频和文件分发应用改变了从服务器到住宅ISP的上载流量，因而给ISP带来压力；</p>
  </li>
  <li>
    <p>安全性。因为其高度的分布和开放式，P2P应用也可能给安全带来挑战；</p>
  </li>
  <li>
    <p>激励。如何说服用户资源向应用提供带宽、存储和计算资源？这是一个问题；</p>
  </li>
</ul>

<h5 id="212-进程通信">2.1.2 进程通信</h5>

<ul>
  <li>进程与计算机网络之间的接口</li>
</ul>

<p>多数应用程序是由通信进程对组成的，运行在不同端系统上的进程对之间通过计算机网络来实现通信。所以，在应用程序进程和计算机网络之间存在一个接口，该接口被称为套接字。更为准确的说，==套接字是同一台主机内应用层和运输层之间的接口==。由于该套接字是建立网络应用程序的可编程接口，因此套接字也被称为应用程序和网络之间的应用编程接口（Application Programming Interface）</p>

<p>应用程序开发者可以控制套接字在应用层的一切内容，但是对于运输层的相关部分，几乎没有控制权，可以做的有：选择传输层协议和设定几个传输层参数，比如最大缓存和最长传输层报文长度</p>

<ul>
  <li>进程寻址</li>
</ul>

<p>为了向特定目的进程发送报文，发送机进程需要知道接收进程（更为准确的说是，接收进程对应的套接字）的标记。该标记由两部分组成：接收进程所在的主机地址和接收进程在该主机中的标记；在因特网中，主机由IP地址标记，其中IP地址是一个32位（IPV4）标记；而接收进程（或者说是其对应的套接字）使用端口号标记；一些常用的应用程序有着固定的端口号，比如Web服务器使用80端口、邮件服务器（运行SMTP协议）使用25端口等</p>

<blockquote>
  <p>套接字是用网络节点的IP地址和端口号来标识的。</p>
</blockquote>

<h5 id="213-可供应用程序使用的运输服务">2.1.3 可供应用程序使用的运输服务</h5>

<ul>
  <li>可靠数据传输</li>
  <li>吞吐量（带宽敏感）</li>
  <li>定时</li>
  <li>安全性</li>
</ul>

<h5 id="214-因特网提供的运输服务">2.1.4 因特网提供的运输服务</h5>

<p><img src="../images/afdgsag" alt="img" /></p>

<p>TCP服务</p>

<p>TCP服务模型包括了面向连接的服务和可靠数据传输服务。</p>

<p>面向连接的服务：在应用层数据报文开始流动之前，TCP会在客户端和服务器端相互交换传输层控制信息。这个握手过程将提示客户端和服务器端，让它们为即将到来的大量分组做好准备；握手阶段接收后将建立一个TCP连接。这条链接是全双工的，即连接双方使用该条链接可以同时进行报文的收发。这条连接将在通讯结束后拆除；</p>

<p>可靠的数据传输：应用程序使用TCP协议可实现无差错、按适当顺序交付所有发送的数据，没有字节的丢失和冗余；</p>

<p>TCP服务还提供了拥塞控制机制。该机制不一定会给通行双方带来好处，但是会给网络带来整体好处；当发送方和接收方之间的网络出现拥塞时，TCP将使用拥塞控制机制来使网络恢复正常</p>

<p>UDP服务</p>

<p>UDP服务是一种不提供不必要服务的轻量级运输协议。它仅提供最小服务。UDP是无连接的也就是说通信之前没有握手；UDP不提供数据的可靠传输；UDP也没有拥塞控制机制。有些应用场景下，UDP协议将带来更多的便利和效率，比如DNS和一些因特网电话服务（为了避免拥塞控制协议的控制而使用UDP）</p>

<p>传输层无法提供的服务</p>

<p>从可靠数据传输、吞吐量、定时、安全性等四个角度来看运输层提供的服务，我们发现，运输层无法对吞吐量和定时做出保证。但是，今天的因特网能够为时间敏感的应用提供满意的服务，尽管它并不提供任何定时或者带宽保证；</p>

<h5 id="215-应用层协议">2.1.5 应用层协议</h5>

<p>应用层协议定义运行在不同端系统上的应用程序进程如何相互传递信息。涉及的内容包括：交换的报文类型（请求或者响应）、报文中包含哪些字段、字段如何被解释、一个进程何时收发报文并如何对报文进行响应等内容</p>

<p>需要注意的是，应用层协议是网络应用的一部分</p>

<h5 id="221-http概述">2.2.1 HTTP概述</h5>

<p>HTTP（Hyper Text Transfer Protocol）（超文本传输协议）是WEB的应用层协议，它是Web的核心；HTTP有两部分实现，一个客户端程序一个服务器程序；HTTP定义了客户和服务器进行报文交换的方法；</p>

<p>Web页面是由对象组成的，==一个对象是一个文件，它们通过一个URL地址进行寻址==。客户和服务器交互的核心思想是客户通过HTTP请求对服务器发出对Web页面的请求报文，服务器收到该报文后将返回包含该对象的HTTP响应报文。URL地址由两部分组成：存放对象的服务器主机名和对象的路径名</p>

<p>HTTP使用<strong>TCP</strong>作为它的传输层协议；HTTP客户首先发起一个与服务器的TCP连接，需要注意的是，服务器根据请求作出响应，但是不存储任何关于该客户的状态信息；也正因为这样，HTTP被称为<strong>无状态协议</strong>。同时，Web使用了客户端-服务器的应用体系结构（CS架构）；其中web服务器总是开着的</p>

<h5 id="222-非持续连接和持续连接">2.2.2 非持续连接和持续连接</h5>

<p>在因特网应用程序中，客户端和服务器将在很长的时间范围里通信；应用程序将根据自身的特点，选择以规则的间隔周期性性发出请求也可以间断性一个个发出请求。当通信是使用TCP协议时，服务器端需要做出一个决定：这些请求是使用一个TCP连接完成还是通过独立的TCP连接完成。如果采取前一个方法，则称应用程序使用==持续连接==，如果使用后一种方式，则称为==非持续连接==。</p>

<p>HTTP既可使用持续连接也可以使用非持续连接。尽管<strong>HTTP在静默情况下使用==持续连接==</strong></p>

<p>大部分浏览器会打开5~10个并行的TCP链接，而每条链接处理一个请求响应事务，当然也可以设置为一个，这样就是串行了。</p>

<h5 id="223-http报文格式请求报文和响应报文">2.2.3 HTTP报文格式：请求报文和响应报文</h5>

<p><img src="../images/20190324192025583.png" alt="img" /></p>

<p>一个请求报文具有至少一行的内容。请求报文的第一行称为<strong>请求行</strong>，其后继的各行被称为<strong>首部行</strong>。请求行包含三个内容：方法字段、URL字段、HTTP版本；其中方法字段可为：GET、POST、PUT、DELETE、HEAD等。URL字段里可以传递请求对象的标志；</p>

<p>首部行包含是否在发送完响应报文后关闭TCP连接的Connection；请求的主机地址（<strong>该头部信息被Web高速缓存所要求</strong>）；浏览器版本；可接受的语言等头部信息；</p>

<p>在首部行之后一个空行，之后便是请求的“实体体”。该实体体可以在POST方法里传递Form表单内容或者传递其它一些二进制流数据等。值得注意的是，表单也不一定必须使用POST方法。如果使用get,实体体为空，会显示在url中。</p>

<p>==Mozilla/5.0版本。服务器需要浏览器类型信息来向不同类型的浏览器发送同一对象的不同版本。==</p>

<p>Head类似于get方法，将会用一个http报文进行响应，但是不返回请求对象，经常用作调试跟踪。put方法允许用户上传对象到指定的Web服务器上指定的路径。Delete方法允许用户或应用程序删除Web服务器上的对象。<img src="../images/4272a5f6cddc46f180b003fd6598e094.png" alt="在这里插入图片描述" /></p>

<p><img src="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzI2NDcy,size_16,color_FFFFFF,t_70" alt="img" /></p>

<p>响应报文总体上也分三个部分，第一部分是状态行，包含HTTP版本、状态以及状态信息等内容；第二部分是首部行，包含发送日期、服务器类型、上一次修改请求资源的时间、内容的类型等内容。第三部分是实体体。实体体包含请求对象本身。</p>

<p>这里的Date是从文件系统中检索到该对象，插入到响应报文，并发送该响应报文的时间。</p>

<p>常见状态码
<strong>200：请求成功 处理方式：获得响应的内容，进行处理</strong></p>

<p>301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源 处理方式：重定向到分配的URL</p>

<p><strong>400：非法请求 处理方式：丢弃</strong></p>

<p><strong>404：没有找到 处理方式：丢弃</strong></p>

<p>505：服务器不支持请求报文使用的http版本。</p>

<p><img src="../images/9a2c41b8d49c435bb67bff849a21822f.png" alt="在这里插入图片描述" /></p>

<h5 id="224-用户与服务器的交互cookie">2.2.4 用户与服务器的交互：cookie</h5>

<p><img src="../images/asdgwe" alt="img" /></p>

<p>前面提到，HTTP是无状态协议，但是Web站点为了识别用户身份或者限制用户访问的时间或者将用户访问的内容同用户身份相关联，Web站点可以使用Cookie技术；</p>

<p>当用户第一次访问网站时，服务器会创建一个唯一的标识号，在其后端数据库中创建一个条目，并将该标识号作为cookie号返回。此cookie编号存储在用户的主机上，并由浏览器进行管理。在随后的每次访问（和购买）过程中，浏览器都会将cookie号码发送回网站。因此，该网站知道该用户（更确切地说，该浏览器）何时访问该网站。</p>

<p>Cookie技术包含4个组件</p>

<p>​    HTTP响应报文里增加一个关于Cookie的首部行；
​    HTTP请求报文里增加一个关于Cookie的首部行；
​    用户端系统保留一个Cookie文件，由浏览器保存维护；
​    Web站点建立Cookie和用户身份的关联；</p>

<p>虽然，Cookie的使用方便了用户也方便了服务端，但是它的使用存在争议，因为使用Cookie被认为是对用户隐私的一种侵犯，因为Web站点可以通过Cookie得到很多用户的信息，并有可能将这部分信息卖给第三方等</p>

<h5 id="225-web缓存">2.2.5 Web缓存</h5>

<p>Web缓存器也被称为代理服务器，它代表初始web服务器来满足HTTP请求。它有自己的存储空间，并在存储空间里保持有最近请求过的对象的副本；可以通过配置浏览器，将所有指向初始服务器的请求首先指向代理服务器。</p>

<p>当代理服务器收到一个HTTP请求后，它将检查本地是否缓存过该对象，如果缓存过该对象，将检查是否过期，如果没有过期，则直接将该对象返回给浏览器；如果本地不存在或者存在已过期，则代理服务器将根据请求报文里的Host首部行以及请求行里的URL字段向初始服务器发出请求，然后将响应对象返回给浏览器并缓存在本地。</p>

<p>通常，代理服务器与客户端的通信速度要快于初始服务器与客户端的连接速度；Web代理服务器可以大起大减少对客户请求的响应时间；而且，缓存器能从整体上大大降低因特网上的web流量，从而有助于提高所有应用程序的性能；</p>

<p>通过使用内容分发网络（Content Distribution Network），Web缓存器正在因特网中发挥越来越重要的作用</p>

<p><strong>Web缓存即是客户又是服务器</strong></p>

<h4 id="23-文件传输协议ftp">2.3 文件传输协议（FTP）</h4>

<p>HTTP和FTP都是应用层协议，它们都运行在TCP协议之上，但是它们之间也有一些重要区别，其中一个就是FTP使用连个并行的TCP连接来传输数据，一个TCP被称为控制连接，用来传输FTP命令；一个TCP连接被称为数据连接，用于传输文件数据；因为FTP协议内，控制信息是通过一个独立的TCP连接传输，所以我们称FTP的控制信息是带外传送的；如果控制信息和数据信息通过同一个TCP传输，则称为带内传送。TCP控制连接端口21，数据连接端口20</p>

<p>HTTP和FTP都是应用层协议，它们都运行在TCP协议之上，但是它们之间也有一些重要区别，其中一个就是FTP使用连个并行的TCP连接来传输数据，一个TCP被称为控制连接，用来传输FTP命令；一个TCP连接被称为数据连接，用于传输文件数据；因为FTP协议内，控制信息是通过一个独立的TCP连接传输，所以我们称FTP的控制信息是带外传送的；如果控制信息和数据信息通过同一个TCP传输，则称为带内传送。TCP控制连接端口21，数据连接端口20</p>

<h4 id="24-因特网中的电子邮件">2.4 因特网中的电子邮件</h4>

<p>因特网电子邮件系统有三个核心组件：用户代理、邮件服务器、SMTP（简单邮件传输协议，Simple Mail Transfer Protocol）。</p>

<p>邮件服务器构成了电子邮件系统的核心。每个收发方在邮件服务器上拥有一个邮箱；一个典型的电子邮件发送过成为：发送方通过用户代理将邮件传送到发送方的邮件服务器，然后再传输到接收方的邮件服务器，然后邮件被分发到接收方的邮箱里；接收方从邮件服务器里获取自己的邮件时需要通过邮件服务器的验证</p>

<p>SMTP是因特网中电子邮件的主要应用层协议，它使用TCP可靠数据传输从发送方的邮件服务器向接收方的邮件服务器发送邮件；在每台邮件服务器上同时运行SMTP服务器和SMTP客户端。当邮件服务器接收其他邮件服务器的邮件时，它表现为SMTP服务器，当邮件服务器向其他邮件服务器发送邮件时，表现为SMTP客户端。</p>

<h5 id="241-smtp">2.4.1 SMTP</h5>

<p>SMTP报文一般不<strong>使用中间邮件服务器发送报文</strong>，也就是邮件不会在中间某个邮件服务器保留；在SMTP握手阶段，SMTP客户端将介绍发送方和接收方的邮箱地址；一旦介绍完毕后，SMTP客户端将开始发送报文</p>

<h5 id="242-smtp与http的对比">2.4.2 SMTP与HTTP的对比</h5>

<p>HTTP和SMTP都是用TCP协议；持续的HTTP和SMTP都是用持续连接；但是两者也有区别。</p>

<ul>
  <li>
    <p>首先HTTP被设计为一个Pull协议，而SMTP被设计为一个Push协议。即用户通过HTTP主动向服务器请求内容，而SMTP则是客户将内容推向服务器端；</p>
  </li>
  <li>
    <p>第二个区别就是HTTP传输的数据不一定是用ASCII字符，但是SMTP则只能使用ASCII字符；</p>
  </li>
  <li>
    <p>第三个重要区别就是，HTTP将每个对象封装在自己的响应报文里，而SMTP则将所有的报文对象放到一个报文之中；</p>
  </li>
</ul>

<h5 id="244-邮件访问协议">2.4.4 邮件访问协议</h5>

<p><img src="../images/20190324194858455.png" alt="img" /></p>

<p>需要注意的是，SMTP是邮件服务器之间发送邮件报文的协议，并不是用户通过代理和邮件服务器之间通信的协议；用户代理使用邮件访问协议来从邮件服务器上获取邮件信息；目前常用的邮件访问协议有第三版的邮局协议POP3（Post Office Protocol-Version 3）、因特网邮件访问协议（IMAP，Internet Mail Access protocol）和HTTP</p>

<ul>
  <li>POP3</li>
</ul>

<p>POP3是一个非常简单的协议，因为简单，所以功能有限；POP3使用端口110来建立TCP连接（SMTP使用端口25）；POP3按照三个阶段进行工作：特许、事务处理和更新；在特许阶段，用户代理发送密码和用户名，进行身份鉴别；第二阶段，用户代理取回报文，同时还可以做删除、取消删除等标记或者统计邮件信息；第三个阶段是在用户退出后，POP3结束会话，删除被标记的邮件；</p>

<p>一个需要注意的是，POP3用户代理可以使用两种事务处理模式：一种是==下载并删除==，另一种是==下载保留==；POP3代理发出的命令和其工作模式相关；下载并删除的方法存在的问题是，如果用户在一台设备上查看了邮件（下载了邮件）后，邮件将被删除，那么在其他设备上将无法查看邮件；这给用户带来一定的不便。使用下载保存方式，则用户下载邮件后，邮件还在服务器上。</p>

<ul>
  <li>IMAP</li>
</ul>

<p>POP3协议无法为用户提供邮件分类管理的功能，虽然用户可以通过将邮件下载到本地，然后由用户代理程序做分类管理，但是处理的结果是无法同步到其他查看设备上的。为了解决这一问题，IMAP诞生了。IMAP是一个邮件访问协议，比POP3要复杂的多，当然也就有更多的特色了。</p>

<p>（远程）IMAP将每一份邮件和一个一个文件夹联系起来，当报文第一次到达服务器时，它与收件人的INBOX相关联。收件人可以将邮件移到新创建的文件夹，阅读邮件，删除邮件等。IMAP允许用户在不同文件夹里移动邮件并且查询邮件。值得注意的是，IMAP服务器维护了IMAP会话的用户状态信息，但是POP3并不；IMAP协议还允许用户代理获取报文组件而不是报文整体。</p>

<ul>
  <li>基于Web的电子邮件</li>
</ul>

<p>这种方式主要是指，用户<strong>使用HTTP协议和邮件服务器通信</strong>。用户代理就是普通的浏览器，但是，邮件服务器之间还是使用SMTP协议的</p>

<h4 id="25-dns因特网的目录服务">2.5 DNS：因特网的目录服务</h4>

<p>域名系统（Domain Name System ，DNS）：进行主机名到IP地址的转化的目录结构（RFC 1034/RFC 1035）</p>

<ul>
  <li>一个由分层的DNS服务器（DNS Server）实现的分布式数据库</li>
  <li>使得主机能够查询分布式数据库的应用协议</li>
</ul>

<p>DNS运行在UDP之上，使用53号端口</p>

<h5 id="251-dns-提供的服务">2.5.1 DNS 提供的服务</h5>

<p>除了提供主机名到IP地址的转换外，DNS还提供以下重要服务：</p>

<ul>
  <li>
    <p>主机别名：虽然，主机名比起IP地址好记多了，但是有时候我们的主机名仍然很长，很不好记忆，所以我们需要为主机名再起一个名字，这就是主机别名，DNS不但提供主机名到IP地址的转换服务，还提供主机名与主机别名的转换；此时主机名被称为规范主机名；</p>
  </li>
  <li>
    <p>邮件服务器别名：DNS同样也提供邮件服务器主机名和别名的转换服务，实际上，<strong>公司的邮件服务器和Web服务器可以使用相同的主机别名</strong>；MX记录允许一个公司的邮件服务器和Web服务器使用相同的主机名。</p>
  </li>
  <li>
    <p>负载分配：DNS也被用在冗余的服务器之间分配负载。每个服务器有着不同的IP地址，但是它们都和同一个主机名相关联，也就是一个IP地址集合同一个规范主机名相联系；当某个DNS服务器收到DNS请求时，该服务器奖使用IP地址的整个集合作为相应，但是在每个应答中，循环这些地址的次序。因为客户端通常都是使用IP地址集合的首个元素，所以DNS就在冗余的Web服务器之间分配了负载。同理，多个邮件服务器可以具有相同的别名。</p>
  </li>
</ul>

<h5 id="252-dns-工作机理概述">2.5.2 DNS 工作机理概述</h5>

<p>​	<strong>DNS采用分布式的设计方案</strong>，实际上，DNS是一个在因特网实现分布式数据库的精彩范例！而之所以这样做，是因为，<strong>单一的DNS服务器无法解决单点故障、无法保证通信容量以及无法临近所有的查询主机和维护困难</strong>等问题</p>

<ul>
  <li>
    <p>根DNS服务器：因特网上有13个根DNS服务器，大部分分布在北美洲，尽管我们可以将这13个根DNS服务器视为单个的服务器，但是每台服务器实际上是一个冗余的计算机网络以提供安全性和可靠性；</p>
  </li>
  <li>
    <p>顶级域DNS服务器：负责顶级域名，如com，org，net，edu，gov以及各个国家的顶级域名的转换。</p>
  </li>
  <li>
    <p>权威DNS服务器：因特网上，具有公共可访问主机的每个组织机构必须公共可访问的DNS记录，这些记录将主机名映射为IP地址。一个组织的权威DNS服务器收藏了这些DNS记录，多数大学和大公司实现和维护它们自己的基本和辅助（备份）权威DNS服务器；当然，也可以通过付费的方式，将相关的信息插入到其它权威服务器中；</p>
  </li>
</ul>

<p>除了上面三种DNS服务器，还有一种不在DNS层次结构之中，但是很重要的DNS，是<strong>本地DNS服务器</strong>。本地DNS服务器通常邻近其所在网络的其他主机。当主机发出DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将请求转发到DNS服务器层次结构中。</p>

<p>DNS查询有两种，一种是递归查询一种是迭代查询；实践中，查询通常满足这样的模式：<strong>从请求主机到本地DNS服务器的查询是递归的，其余查询是迭代的。</strong>所谓迭代就是，如果请求的接收者不知道所请求的内容，那么接收者将扮演请求者，发出有关请求，直到获得所需要的内容，然后将内容返回给最初的请求者。也就是说，在递归查询中，一定要给请求者想要的答案；迭代查询则是指，如果接收者没有请求者所需要的准确内容，接收者将告诉请求者，如何去获得，但是自己并不去发出请求。</p>

<p><img src="../images/878494" alt="img" /></p>

<p>从请求主机到本地DNS服务器的查询是递归的，其余查询是迭代的。</p>

<p><img src="../images/9498498" alt="img" /></p>

<p>所有的都是迭代查询</p>

<ul>
  <li><strong>DNS缓存</strong></li>
</ul>

<p>DNS缓存实际上是为了盖上时延性能并且减少在因特网上传输的DNS报文数量而引入的。DNS缓存原理十分简单，每当DNS服务器发出请求后收到回答时，就将回答的内容缓存在它自己的主机空间上。这样，如果有相同的请求到达时，就不需要再去发出请求，直接使用缓存即可；因为有了缓存，本地DNS就可以直接提供一些经常被访问的主机名所对应的IP地址，而不需要询问根DNS服务器了。需要注意的是，缓存不可避免的一个问题：有效时间。如果缓存过时而未得到更新，那么就会导致一些请求失败。</p>

<p>缓存技术就是一种典型的使用空间换时间的策略</p>

<h5 id="253-dns-记录和报文">2.5.3 DNS 记录和报文</h5>

<p>DNS服务器资源记录（Resource Record，RR）</p>

<ul>
  <li>具体为四元组形式（Name，Value，Type，TTL）</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type=A：则name为主机名，value为对应的IP地址；
type=NS：则name为域，value为如何获得该域下主机IP地址的权威DNS服务器的主机名；
type=CNAME：则value为name（本身为主机别名）所对应的主机的规范主机名；
type=MX：则value为name(对应的邮件服务器)的规范主机名；
</code></pre></div></div>

<p>如果为了获得邮件服务器的规范主机名，请求一条MX记录；为了获得其它服务器的规范主机名，请求一条CNAME记录</p>

<p>所以如果一条记录为type=A，则它直接包含了需要的信息；如果是NS，需要进一步得到权威DNS服务器的IP地址（同时返回一条NS记录，并返回一条以该NS记录的value值为name的A记录）希望得到一条A记录；而type=CNAME和MX的记录则实现了主机别名到主机规范名的转换，可以通过该规范名继续构建查询链条，直到获得希望的IP地址；</p>

<ul>
  <li>根据Type=A（Name标识主机名）、CNAME（主机别名）、NS（域名）、MX（邮件主机名）</li>
</ul>

<p><img src="../images/asdfasdf" alt="" /></p>

<ul>
  <li>向DNS数据库中插入数据</li>
</ul>

<p>需要在注册登记机构完成这一任务，当你注册一个域名时，需要向该机构提供你的基本和辅助DNS服务器的名字和IP地址；该注册机构将确保一个类型为NS和类型为A的记录输入对应的顶级域名服务器；这样就完成了插入数据</p>

<h4 id="26-p2p-应用">2.6 P2P 应用</h4>

<h5 id="261-p2p-文件分发">2.6.1 P2P 文件分发</h5>

<p>BitTorrent 是一种用于文件分发的流行P2P协议；用BitTorrent的术语来说，参与一个特定文件分发的所有对等方的集合被称为一个洪流；在一个洪流中的对等方彼此下载等长度的文件块；当一个对等方下载文件块的时候，也向其他对等方发送了多个块；一旦某对等方获得了完整文件，就可以自私地离开洪流或者大公无私地留下来继续向其他对等方发送文件.</p>

<p>$D_{cs}=max{\frac{NF}{u_s},\frac{F}{d_{min}}}$</p>

<p>服务器必须向 N 个对等方发送 F 的一个复件，每个对等方都必须下载一个F</p>

<p>$D_{P2P}=max{\frac{F}{u_s},\frac{F}{d_{min}},\frac{NF}{u_s+\sum u_i}}$</p>

<p>服务一必须至少发送一次 F ，每个对等方必须下载一个 F ，P2P 洪流中所有的对等方加上服务器，必须上传 N 次 F 。</p>

<ul>
  <li>BitTorrent</li>
</ul>

<p>最稀缺优先：这样最稀缺的块得到更迅速的分发</p>

<p>最高速率优先</p>

<h5 id="262-分布式散列表">2.6.2 分布式散列表</h5>

<h3 id="第三章-运输层">第三章 运输层</h3>

<p>传输层协议为运行在不同端系统上的应用进程之间提供<strong>逻辑通信</strong>功能；应用层进程使用传输层提供的逻辑通信功能而无需考虑实现通信的物理基础设施的细节；</p>

<p>值得注意的是，<strong>传输层协议是在端系统中实现的而不是在路由器中实现的</strong>。传输层接收来自应用层的报文并通过添加传输层首部以生成传输层报文段。在生成过程中可能会对来自应用层的报文加以分割；然后在发送端系统中，运输层会将这些报文段交给网络层；网络层将其封装成网络层分组，也被称为数据报，然后向目的地发送。路由器不会检查封装在数据报中的传输层报文段的字段；在接收端，网络层从数据报中抽取传输层报文段，并将其交给传输层，传输层接收到报文段后，使该报文段中的数据被接收进程所使用。</p>

<h5 id="312-因特网传输概述">3.1.2 因特网传输概述</h5>

<h5 id="311-传输层和网络层">3.1.1 传输层和网络层</h5>

<ul>
  <li>网络层提供<strong>主机</strong>之间的逻辑通信机制</li>
  <li>传输层提供<strong>应用进程</strong>之间的逻辑通信机制，位于网络层之上，依赖于网络层服务，对网络层服务进行（可能的）增强</li>
</ul>

<p>因特网为应用层提供了截然不同的两种传输层协议：UDP（用户数据报协议）它提供一种<strong>不可靠、无连接</strong>的服务；另一种是TCP，它提供<strong>可靠的，面向连接</strong>的服务，有拥塞控制，流量控制机制和连接建立过程； 我们将运输层分组称为报文段 ( segment) 。</p>

<p>简单了解一下因特网的网络层，网络层协议有一个名字即IP，即网际协议。IP为主机间提供逻辑通信，IP的服务模型为==尽力而为交付服务==（best-effort delivery service）。它<strong>不保证报文段的交付</strong>、<strong>不保证报文段按序交付</strong>、<strong>不保证报文段中数据的完整性</strong>；即IP提供一种不可靠的服务；每台主机都需要有一个网络层地址，即IP地址。</p>

<p>将主机间交付扩展到进程间交付被称为运输层的多路复用（transport-layer multiplexing）与多路分解（demultiplexing）</p>

<h4 id="32-多路复用与多路分解">3.2 多路复用与多路分解</h4>

<p>实际上，<strong>传输层和应用程序进程之间通过Socket（套接字）关联</strong>，这样通过Socket就可以区别同一主机上的不同应用进程，从而传输层提供服务变为可能；<strong>传输层从同一台主机上的不同Socket接收数据的过程称为多路复用</strong>；<strong>传输层向同一台主机上的不同Socket传输数据的过程称为多路分解</strong>；为了实现多路复用和多路分解，我们需要标志套接字，并将相关信息添加到报文段中。</p>

<p>将运输层报文段中的数据交付到正确的套接字的工作称为<strong>多路分解</strong> ( demultiplexing)。在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息(这将在以后用于分解)从而生成报文段，然后将报文段传递到网络层，所有这些工作称为<strong>多路复用</strong> ( nmhiplexing) 。</p>

<p>实际上，<strong>每个套接字都有一个唯一的ID，被称为端口号</strong>；而在传输层接收到来自应用程序的分组并通过添加传输层首部而形成报文段的过程中，该端口号被写入；端口号大小在0-65535之间，其中0-1023属于周知端口号，它们为特定的Socket而拥有。</p>

<ul>
  <li>无连接的多路复用与多路分解</li>
</ul>

<p>需要注意的是，在创建Socket的时候，是由传输层为之分配端口号；一个<strong>UDP套接字由二元组标志</strong>：（目的IP地址，目的端口号）；如果两个UDP报文段有不同的源IP地址或者源端口号，但是有相同的目的IP和目的端口号的话，它们将通过同一个Socket到达同一个应用程序。</p>

<ul>
  <li>面向连接的多路复用与多路连接</li>
</ul>

<p>TCP协议中的Socket是通过一个<strong>四元组来标记的</strong>：（源IP地址，源端口号，目的IP地址，目的端口号）；两个具有不同源IP地址或者源端口号，但有相同的目的IP地址和目的端口号的TCP报文段将通过两个不同的Socket进入同一应用进程；这也表示，一个应用进程可以关联多个Socket，而一个Socket将只关联一个应用进程；常常，这样的对应关系是通过线程来实现的：一个进程有多个线程，而每个线程关联了一个Socket；这样做可以提高服务器性能嘛</p>

<p>实际上，传输层就是根据这些信息来实现多路分解的；而这些信息是在多路复用的时候被放置在报文段中的</p>

<h5 id="331-udp报文结构">3.3.1 UDP报文结构</h5>

<p><img src="../images/20210717231357347.png" alt="在这里插入图片描述" /></p>

<h5 id="332-udp校验和">3.3.2 UDP校验和</h5>

<p>检测目的：检测UDP段在传输中是否发生错误（如位翻转）</p>

<p><img src="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhcHB5amFjb2I=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>

<p>溢出回卷</p>

<p>加反加判</p>

<h4 id="34-可靠数据传输原理">3.4 可靠数据传输原理</h4>

<h5 id="341-构造可靠数据传输协议">3.4.1 构造可靠数据传输协议</h5>

<ul>
  <li>rdt1.0（完全可靠信道）</li>
</ul>

<p>接收方不需要提供任何反馈信息给发送方</p>

<ul>
  <li>rdt2.0（具有比特差错）</li>
</ul>

<p>自动重传请求（Automatic repeat reQuest）ARQ协议</p>

<ol>
  <li>差错检测</li>
  <li>接收方反馈</li>
  <li>重传</li>
</ol>

<p>停等协议：rdt2.0的发送端每发送一个分组需要等待接收端的确认信号，这种协议被称为<strong>停等协议</strong>。</p>

<ul>
  <li>rdt2.1</li>
</ul>

<p>引入了1比特的序号位</p>

<ul>
  <li>rdt2.2</li>
</ul>

<p>rdt 2.2 是在有比特差错信道上实现的一个无NAK的可靠数据传输协议。</p>

<p>rdt 2.1和rdt 2.2的区别在于，接收方此时必须包括由一个ACK报文所确认的分组序号，也即是ACK报文中包含序号</p>

<ul>
  <li>rdt3.0（经具有比特差错的丢包信道的可靠数据传输）</li>
</ul>

<p>在 rdt 3.0 中，丢包的问题让发送方解决。不管是发送的分组丢失，还是接收方返回的确认分组丢失，只要在经过一定的时延后，让发送方重发该分组即可。</p>

<p>由此产生的 冗余数据分组 则由接收方通过序号处理。为了实现基于时间的重传机制，需要一个倒计时定时器</p>

<p>因为分组序号在 0 和 1 之间交替，因此 rdt 3.0 有时被称为 比特交替协议。</p>

<p><img src="../images/5489" alt="img" /></p>

<h5 id="241-流水线可靠数据传输协议">2.4.1 流水线可靠数据传输协议</h5>

<p>rdt 3.0的核心问题在于他是一个<strong>停等协议！</strong></p>

<p>rdt 3.0 是一个功能正确的协议，但是由于它是一个停等协议，大部分的时间都浪费在等待确认上面，所以性能不好。</p>

<p>解决这种特殊性能问题的一个简单的方法是：不使用停等方式运行，允许发送方发送多个分组而无需等待确认。这种技术被称为<strong>流水线</strong>。</p>

<p>要使用流水线技术，则须：</p>

<ul>
  <li>
    <p>增加序号范围。因为要传送多个分组，而每个传输中的分组必须有一个单独的序号。</p>
  </li>
  <li>
    <p>协议的发送方和接收方两端必须能缓存多个分组。发送方至少得能缓存那些已发送但未确认的分组，而接收方或许也需要缓存那些已经正确接收的分组。</p>
  </li>
  <li>
    <p>所需序号的范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。</p>
  </li>
</ul>

<p>流水线的差错恢复有两种基本方法：</p>

<p>回退 N 步</p>

<p>选择重传</p>

<h5 id="343-回退n步">3.4.3 回退N步</h5>

<ol>
  <li>使用序号</li>
  <li>累计确认</li>
  <li>校验和</li>
  <li>超时/重传操作</li>
</ol>

<p>在回退N步中，发送方维护一个N——窗口大小和一个base——发送方期待收到的最小待确认分组序号，同样也是窗口的起点，还有一个next Sequence变量，表示上层需要发送分组时，可以使用的序号。这样全部序号就被划分为0-base-1，这一部分的分组是已发送且收到接收方确认的分组，base~next Sequence-1这一部分的分组是已发送但是尚未收到确认的，其中base是尚未收到确认的最小序号；next-1~base+N-1表示当前发送方可以使用的序号，表示一种发送能力；当发送方收到确认号为base的确认分组后就会向前移动窗口，所以回退N步也被称为滑动窗口协议</p>

<ul>
  <li>
    <p>[0，base - 1] 对应已经发送并被确认的分组</p>
  </li>
  <li>
    <p>[base，nextseqnum - 1]对应已经发送但未被确认的分组</p>
  </li>
  <li>
    <p>[nextseqnum，base + N - 1] 对应要被立即发送的分组</p>
  </li>
  <li>
    <p>大于或等于 base + N 的序号是不能使用的</p>
  </li>
</ul>

<p>N 被称为窗口长度(window size)，GBN 协议也常被称为滑动窗口协议(sliding-window protocol)</p>

<p><img src="../images/20210718192409159.png" alt="img" /></p>

<p>发送方需要响应的事件有：上层调用、收到ACK、超时事件；</p>

<ul>
  <li>
    <p>上层调用：检查next Sequence是否在窗口之内，如果在，这说明发送方还有发送能力，发送；</p>
  </li>
  <li>
    <p>收到ACK：回退N步策略对序号为n的分组采取<strong>累积确认</strong>的方式，即当收到序号为n的ACK时，表明序号小于等于n的分组全部到位；</p>
  </li>
  <li>
    <p>超时事件：如果发生超时事件，那么发送方会<strong>重发所有已发送但是未确认的分组</strong>，即分组号在base和next sequence-1之间的所有分组；这也是为什么叫“回退N步”，如果收到一个ACK，则定时器会重行启动；如果没有待确认的分组，定时器将被终止；</p>
  </li>
</ul>

<p>在接收方，只需要记住唯一的expectedseqnum。如果到达分组的序号为n且该分组是按序到达，那么发送ACK，这就导致发送方移动窗口；</p>

<p>如果不是按序到达，接收方没有缓存，<strong>丢弃所有失序分组</strong>，重新确认序列号最大的、按序到达的分组，丢弃一个正确接收的失序分组可能会导致更多的重传。</p>

<p><img src="../images/8494949" alt="在这里插入图片描述" /></p>

<h5 id="344-选择重传">3.4.4 选择重传</h5>

<p>GBN 的缺点：单个分组的差错就能够引起 GBN 重传大量分组，许多分组根本没有必要重传。 选择重传（SR）协议通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组而避免了不必要的重传。</p>

<p><img src="../images/5243486.png" alt="img" /></p>

<p>SR 发送方的事件和动作：</p>

<ul>
  <li>
    <p>从上层接收数据：检查下一个可用于该分组的序号，若在发送方的窗口内，则将数据打包发送。</p>
  </li>
  <li>
    <p>超时：定时器再次用来防止丢失分组。但是现在<strong>每个分组必须得有单独的定时器</strong>。</p>
  </li>
  <li>
    <p>收到 ACK：倘若该分组序号在窗口内，则 SR 发送方将那个被确认的分组标记为已接收。如果该分组的序号等于send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。</p>
  </li>
</ul>

<p>SR 接收方的事件于动作：</p>

<ul>
  <li>
    <p>序号在 [rcv_base，rcv_base + N -1] 内的分组被正确接收。在此情况下，收到的分组落在接收方的窗口内，一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号，则该分组及以前缓存的序号连续的分组交付给上层。</p>
  </li>
  <li>
    <p>序号在 [rcv_base - N，rcv_base - 1] 内的分组被正确接收。<strong>产生一个 ACK，确认该组的ACK</strong>，即使该分组是接收方以前已确认过的分组。</p>
  </li>
  <li>
    <p>其他情况：忽略该分组。</p>
  </li>
</ul>

<p><img src="../images/984191.png" alt="在这里插入图片描述" /></p>

<p><strong>窗口长度必须小于等于序号空间大小的一半！</strong></p>

<h4 id="35-面向连接的运输tcp">3.5 面向连接的运输：TCP</h4>

<ol>
  <li>超时间隔加倍</li>
  <li>快速重传</li>
</ol>

<h5 id="351-tcp连接">3.5.1 TCP连接</h5>

<p>TCP协议之所以被称为是<strong>面向连接</strong>的协议，是因为在一个应用进程可以向另一个应用进程发送数据前，这两个进程将首先“握手”，即它们必须交换一些预报文段，已建立对关于数据传输的参数的共识；作为TCP连接建立的一部分，通信双方都将初始化与TCP连接的许多相关变量</p>

<p>TCP的连接，并不是一条像电路交换网络中端到端的TDM、FDM电路，也不是一条虚电路；其连接状态被端系统所维护而<strong>中间路由器完全忽略了该协议</strong>，中间路由器看到的只是数据，也就是说，TCP只运行在端系统之上；所以，TCP连接更像一种状态而不是物理的、实际的连接</p>

<p>TCP提供<strong>全双工服务</strong>，并且是<strong>点对点的</strong>，数据从A到B的同时，也能从B到A；TCP协议无法提供“多播”服务，一条TCP连接只关联一个发送方和接收方（当然，发送方也是接收方）；</p>

<p>对于TCP建立过程中的“握手”阶段，需要明白的是，手一共握了三次，前两次报文段不承载“有效负载”，第三次握手的时候，报文段是可以装载“有效负载”的；这个过程是这样的：</p>

<ol>
  <li>
    <p>通信的发起方首先发送一个特殊的TCP报文段给接收方，这是第一次握手；</p>
  </li>
  <li>
    <p>接收方收到该报文段后，对该报文段进行响应，此为第二次握手；</p>
  </li>
  <li>
    <p>发送方接收到响应报文段后，发送第三个报文段，<strong>其中包含了有效负载</strong>；</p>
  </li>
</ol>

<p>因为TCP建立的过程，一共发生了三次握手，所以该过程也被称为“三次握手”</p>

<p>MSS（Maximum Segment Size），最大报文长度</p>

<p>MTU（Maximum Transmission Unit），最大传输单元</p>

<h5 id="352-tcp报文段结构">3.5.2 TCP报文段结构</h5>

<p>TCP报文段结构，从整体上来说由首部+数据字段组成；其中数据字段来自应用层，其长度不能大于MSS；首部的常规长度为20字节，但是值得注意的是，TCP首部是可变长的；TCP首部是以32比特为单位组织的，其结构组成如下图：</p>

<p><img src="../images/watermark,type_ZmFuZ3poZW5naGVpdGkDcy,size_16,color_FFFFFF,t_70" alt="img" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>源端口号和目的端口号
这两个数据用于TCP的多路复用和多路分解；分别为16位；

序号
该数据被用于实现可靠数据传输之按序到达，在一个TCP连接中，算是一个报文段的id，同时该id还指示了其所承载的数据的位置信息；占32位；

确认号
该数据表示接收方已经正确接收的报文段的序号，在流水线的差错恢复方案里，不同的恢复策略有不同的意义：回退N步里，当发送方接收到对K的确认号时，表示所有序号小于K的报文段均已到达；而在选择重传里，则仅表示序号为K的报文段被正确接收；

首部长度
TCP的首部是可变长的，所以该字段表示报文段的首部长度，也揭示了应用数据的开始位置；该字段以32比特为单位，占4比特

选项字段
该字段用于在发送方和接收方之间协商MSS的大小，在高速网络环境下，也可用于调节窗口大小；

标记字段
URG表示紧急标记位。当发送方希望一些数据尽快被接收方的上层拿到的时候，就需要用到这个标记位。通常需要搭配16位紧急指针使用，要传递的紧急数据混在普通数据里，16位紧急指针指明了紧急数据在普通数据中的具体位置。

ACK位表示确认号字段的里的值是否有效，如果ACK被置位，那么该报文段就对确认号所指示的报文段进行了确认；

PSH表示催促标记位，可以理解为Push。Client在不断发数据，Server在不断接收数据同时在给Client发送应答，应答报文中包含了16位窗口大小的字段，其实就是在告诉Client自己接收缓冲区剩余空间的大小，以便于Client及时调整自己的发送速度。

SYN表示同步标记位，其实就是申请建立连接的标记位。TCP是面向连接的协议，双方在正常通信之前需要先建立连接，建立连接是一个三次握手的过程。
</code></pre></div></div>

<ol>
  <li>序号和确认号</li>
</ol>

<p>TCP报文段中两个重要的字段是确认号和序号；这两个字段是TCP实现可靠数据传输的重要部分；TCP将数据看作是一个无结构、有序的字节流；值得注意的是，TCP的序号是基于传输的字节流之上，而不是报文段的序列之上；也就是说，来自应用层的数据被TCP包装在多个报文段中，其中第2个报文段的序列号不是2，而是1001，如果MSS为1000。关于确认号，如果采取回退N步策略，那么TCP采用一种累计确认的方法，前面已经提到过，这里就不赘述；一条TCP连接可以采取任意数字作为初始序号，这样可以减少将那些残存在网络中的报文段误认为是新建连接的报文段（新旧连接恰巧采用了相同端口）</p>

<p>​	总体来说，一个报文段的<strong>序号就是该报文段数据字段首字节的序号</strong>；<strong>确认号就是接受主机正在等待接收的数据的下一个字节序号</strong>；值得注意的是，服务端对接收端发来的报文段的确认被装载到一个从服务端发往到接收端的报文段中，这种确认被称为“捎带”</p>

<p>TCP被称为提供==累计确认==</p>

<p>Telnet：应用层协议。</p>

<p>即使报文段没有护具仍有序号。这是因为TCP存在序号字段，报文段必须填入某个序号。</p>

<h5 id="353-往返时间估计与超时">3.5.3 往返时间估计与超时</h5>

<ul>
  <li>估计往返时间</li>
</ul>

<p>TCP使用一种Sample RTT的方法来估计RTT。Sample RTT就是从某报文段发出到收到对该报文段的确认之间的时间量。大多数TCP的实现是在某个时刻做一个Sample RTT测试。TCP并不为已经重发的报文段做Sample RTT测试，它只为传输一次的报文段测量Sample RTT。</p>

<p>TCP 维持一个 SampleRTT 均值（称为EstimatedRTT），一旦获得一个新SampleRTT时，TCP 就会根据下列公式来更新 Estimated RTT，这种方法也被称为指数加权移动平均：<strong>Estimated RTT=(1-a)Estimated RTT+a*Sample</strong></p>

<table>
  <tbody>
    <tr>
      <td>测量RTT的变化也是有价值的。DevRTT用于估算SampleRTT偏离EstimatedRTT的程度。<em>*DevRTT =(1-b)DevRTT+b</em></td>
      <td>Sample RTT-Estimated RTT</td>
      <td>**</td>
    </tr>
  </tbody>
</table>

<p>其中b的推荐值为0.25；当Sample RTT变化较大的时候，DevRTT的值较大，当Sample RTT变化较小的时候，DevRTT就较小；</p>

<ul>
  <li>设置和管理重传超时间隔</li>
</ul>

<p>TCP是如何考虑超时时间的呢？该时间因略大于测量的RTT，过小容易引起不必要的重传，过大时网络对于报文段丢失情况的反应就会变慢；最后TCP采用了如下计算方式：Timeout Interval=Estimated RTT+4*Dev RTT</p>

<p>当出现超时后，TimeOutInteval 值将加倍。一旦报文段收到并更新Estimated RTT后，TimeInteval 就又用上值计算了。</p>

<h5 id="354-可靠数据传输">3.5.4 可靠数据传输</h5>

<ol>
  <li>累计确认</li>
  <li>单个定时器，只重传一个（与GBN）不同</li>
  <li>收到冗余分组，重发确认，希望得到的那个。（与GBN相同）</li>
  <li>收到正确的乱序分组会缓存，发希望得到的ACK</li>
</ol>

<p>TCP使用<strong>超时重传</strong>和<strong>冗余确认</strong>技术来处理超时、丢失等情况；使用<strong>确认号</strong>、<strong>序号</strong>等技术来保证按序到达；使用<strong>校验和</strong>来检验是否报文段在传输过程中是否发生了错误；</p>

<ul>
  <li><strong>1.超时时间加倍</strong></li>
</ul>

<p>在大多数TCP实现中，当发生超时事件时，超时时间并不是从Estimated RTT和Dev RTT推算出来而是直接将超时时间设置为原来的两倍；然而，每当定时器在另两个事件（收到ACK和接收到上层应用数据）发生时，新的超时时间将由上面提到的两个值计算出来；实际上，这是一种形式受限的拥塞控制。</p>

<ul>
  <li><strong>2. 快速重传</strong></li>
</ul>

<p>一旦收到 3 个冗余 ACK，TCP 就执行<strong>快速重传</strong>（fast retransmit）。如果发送方收到冗余ACK，说明有多个报文段到达了接收端，但不是接收端所期望的——这意味着，很有可能发生了丢失。所以发送方可以在定时器过时之前快速重传所丢失的报文段。</p>

<p><img src="../images/9798189.png" alt="img" /></p>

<h5 id="355-流量控制">3.5.5 流量控制</h5>

<p>流量控制是一个速度匹配服务：TCP连接的发送方和接收方都各自维护一个缓存，因此两者的数据交换应该在一个合理的速度范围内：不让对方发生数据溢出；TCP为它的应用程序提供了这种服务：流量控制服务。虽然流量控制和拥塞控制所采取的动作非常相似，但是它们的目的很明显并不同。在接下来的讨论中，我们将假设TCP是这样实现的，即TCP接收方丢弃失序到达的报文段</p>

<p>在TCP首部中有一个接收窗口字段，TCP连接的双方通过该字段来向对方表明自己的窗口大小，即缓存空间的大小；同样，在TCP连接的两端，各自维护着相关的变量：LastByteSent、LastByteAcked；在发送方，这两个变量之间的分组就是已经发送但是尚未确认的分组；而在接收方，LastByteRead表示应用进程下一次读取的数据,LastByteRevd表示最后纳入缓存的报文段编号（注意，我们讨论的前提是TCP会将失序到达的报文段丢弃）；通过这些变量以及报文段首部中窗口大小字段，我们就可以对发送速度做一些控制：在发送方LastByteSent-LastByteAcked应该小于等于接收方的窗口大小rwnd；在接收端A = LastByteRcvd - LastByteRead就是已经使用的空间大小，所以窗口大小rwnd = buffer - A；buffer是接收方缓存。</p>

<p>当接收到窗口大小为0的报文段后，发送方会向接收方<strong>间隔发送只有一个字节的数据</strong>，接收方也会对这个报文进行确认，确认报文段中还包含着rwnd</p>

<h5 id="356-tcp连接管理">3.5.6 TCP连接管理</h5>

<p><img src="../images/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img" /></p>

<ol>
  <li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。（x是随机的）</li>
  <li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号（ack）为 x+1，同时也选择一个初始的序号 y。（y也是随机的）</li>
  <li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。第三次的报文段负载中可以携带客户到服务器的数据</li>
</ol>

<p>x，y随机是为了保证这个建立连接的报文不会被当成之前发送的段，倘若SYN比特出错的话</p>

<p>一旦完成这三个步骤，以后的报文段中的SYN比特都将被置为0</p>

<p><img src="../images/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="img" /></p>

<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>

<ol>
  <li>
    <p>A 发送连接释放报文，FIN=1。</p>
  </li>
  <li>
    <p>B 收到之后发出确认，此时 TCP 属于半关闭状态，<strong>B 能向 A 发送数据但是 A 不能向 B 发送数据</strong>。FIN 不等于 1</p>
  </li>
  <li>
    <p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p>
  </li>
  <li>
    <p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p>
  </li>
</ol>

<p>B 收到 A 的确认后释放连接。</p>

<p>四次挥手的原因</p>

<p>​	客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>

<p>TIME_WAIT</p>

<p>​	客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>

<ol>
  <li><strong>确保最后一个确认报文能够到达</strong>。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
  <li>等待一段时间是为了让<strong>本连接持续时间内所产生的所有报文都从网络中消失</strong>，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ol>

<h4 id="36-拥塞控制原理">3.6 拥塞控制原理</h4>

<h5 id="361-拥塞原因与代价">3.6.1 拥塞原因与代价</h5>

<p>计算机网络拥塞的原因是因为网络中的分组太多，而链路带宽和路由器缓存容量都是有限的；</p>

<ul>
  <li>
    <p>当分组的到达速率接近链路容量时，分组将经历巨大的排队时延；</p>
  </li>
  <li>
    <p>发送方必须执行重传已补偿因为缓存溢出而丢弃的分组</p>
  </li>
  <li>
    <p>发送方遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本。</p>
  </li>
  <li>
    <p>当一个分组沿着一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了；</p>
  </li>
</ul>

<h5 id="362-拥塞控制方法">3.6.2 拥塞控制方法</h5>

<ol>
  <li>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；</li>
  <li>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收。</li>
</ol>

<p>在<strong>端到端拥塞控制</strong>方法中，网络层并没有向传输层拥塞控制提供显式支持，即便网络中存在拥塞，端系统也必须通过对网络行为的观察（如分组丢失与时延）来判断；TCP必须通过端到端的方法解决拥塞控制，因为IP层不会像端系统提供有关网络拥塞的反馈信息。TCP报文段的丢失（超时或者收到3次冗余确认而得知）被认为是网络拥塞的一个迹象，TCP将相应地减小窗口长度；</p>

<p>在<strong>网络辅助的拥塞控制</strong>方法里，网络层会向发送方提供关于网络中拥塞状态的显式反馈消息；比如使用一个比特位来指示网络是否拥塞；拥塞信息从网络反馈到发送方一般有两种方式，其</p>

<ul>
  <li>
    <p>中直接反馈信息可以由网络路由器发送给发送方，这种方式的通知通常采用一种拥塞分组的形式</p>
  </li>
  <li>
    <p>第二种形式的通知是路由器标记或者更新从发送方到接收方的分组中的某个字段来指示拥塞的产生，然后由接收方向发送方通知该网络发生了拥塞。这种形式至少要经过一个完整的往返时间</p>
  </li>
</ul>

<h4 id="37-tcp拥塞控制">3.7 TCP拥塞控制</h4>

<p>我们将TCP发送方的丢包事件定义为：要么超时，要么收到接收方的3个冗余ACK；</p>

<p>TCP拥塞控制算法包含三个主要部分：慢启动、拥塞避免、快速恢复；慢启动和拥塞控制是TCP的强制部分；两者的差异在于对收到的ACK做出反应时增加拥塞窗口(cwnd)长度的方式；快速恢复是推荐部分，对于TCP发送方并非是必须的</p>

<ul>
  <li><strong>1.慢启动</strong></li>
</ul>

<p>TCP连接在开始的时候，其cwnd常设置为一个MSS，然后在慢启动状态每收到一个ACK，cwnd就增加一个MSS；这样的话，在慢启动阶段，发送速率是指数增加的（1,2,4,8…），因为cwnd增加一个下一次就收到两个ACK，就增加两个ACK，cwnd变成4，下次收到四个</p>

<p>何时结束这种指数增长？有三种情况：发送了超时、发生了冗余ACK以及cwnd达到ssthresh（慢启动阈值的速记）。在慢启动阶段，如果发生了超时事件，那么ssthresh就被设置为当前cwnd的一半，然后将cwnd置为1；当cwnd逐步增加到ssthresh时，TCP结束慢启动，进入拥塞避免模式。在拥塞避免模式里，TCP将更谨慎地增加cwnd；如果收到冗余ACK，那么TCP会做一次快速重传，然后进入快速恢复阶段；</p>

<ul>
  <li><strong>2.拥塞避免</strong></li>
</ul>

<p>一旦进入拥塞避免状态，cwnd的值大约是上次遇到拥塞时的一半，所以TCP在每个RTT中，只将cwnd增加一个1个MSS大小；也就是说在拥塞避免阶段，cwnd是线性增加的；</p>

<p>当出现超时时，TCP将cwnd设置为1（进入慢启动），然后将ssthresh更新为cwnd的一半；当收到3个冗余ACK时，<strong>TCP将ssthresh置为cwnd值的一半，并且进入快速恢复状态；</strong></p>

<ul>
  <li><strong>3.快速恢复</strong></li>
</ul>

<p>对于引起 TCP 进入快速恢复状态的缺失报文段，对收到的每个冗余ACK，cwnd的值增加一个MSS。TCP降低cwnd后进入拥塞避免状态</p>

<p>超时事件：cwnd直接设为1个MSS，然后指数增长，达到ssthresh后, 再线性增长，（进入慢启动）</p>

<p>快速恢复：在快速重传之后，发送方将进入快速恢复阶段。在这个阶段，不再使用慢启动或拥塞避免方式逐步增加cwnd。而是调整拥塞窗口大小以便快速恢复到丢失数据包之前的传输率。具体来说，发送方将cwnd设置为ssthresh值（即当前cwnd的一半），然后<strong>每当收到一个新的重复ACK，它将cwnd增加一个报文段的大小。</strong> <strong>当收到新的ACK（表示丢失的数据包已经到达接收方）时</strong>，发送方会立即结束快速恢复阶段，并进入拥塞避免阶段，cwnd将从更新后的ssthresh值开始线性增长。</p>

<h3 id="第四章-网络层">第四章 网络层</h3>

<h5 id="411-转发和路由选择">4.1.1 转发和路由选择</h5>

<ul>
  <li>转发：当一个分组到达路由器一个输入时，将其移到另一个输出链路上的过程</li>
  <li>路由选择（routing）：当分组从发送方流向接收方，网络层（所有路由器）决定的该分组应该经过的路径（最短路选择，详情看路由选择算法（routing algorithm）</li>
</ul>

<blockquote>
  <p>路由和转发之间的关键区别在于：</p>

  <p>转发是路由器将数据包从其输入接口传输到其输出接口的本地操作，发生在非常短的时间尺度(通常是几纳秒)，因此通常在硬件中实现。</p>

  <p>路由是指网络范围内的过程，它决定数据包从源端到目的地的端到端路径。路由发生在更长的时间尺度上(通常是秒)，并且通常在软件中实现。</p>
</blockquote>

<h5 id="412-网络服务模型">4.1.2 网络服务模型</h5>

<p>网络层服务模型（network service model）：定义了分组在发送与接收端之间的网络层特性</p>

<ul>
  <li>确保交付、有交付时延上限、有序分组交付、确保最小带宽、保证最大延时抖动、安全性等</li>
  <li>但是很遗憾，最常用的IP协议只能保证尽力而为（best-effort-service）的服务</li>
  <li>除此之外还有：恒定比特率（Constant Bit Rate，CBR）ATM网络服务，可用比特率（Available Bit Rate，ABR）ATM网络服务这些有保证的服务</li>
</ul>

<p>网络层和传输层差别</p>

<ul>
  <li>传输层面向不同主机进程通信，而网络层只负责把数据送到对应主机</li>
  <li>网络层不同时提供有连接（虚电路网络）和无连接（数据报）的服务，而传输层可以TCP、UDP都能用</li>
  <li>网络层在核心网络（路由器）中和端系统都有实现，传输层只在端系统（主机）</li>
</ul>

<h4 id="42-虚电路和数据报网络">4.2 虚电路和数据报网络</h4>
<p>虚电路（Virtual-Circuit，VC）网络（VCN）：有链接的网络服务，在发送方和接收发之间维护一条链路</p>

<ul>
  <li>源主机和目标主机之间的路径（一系列路由器和链路）</li>
  <li>VC号（标识不同路径不同链路）</li>
  <li>转发表（记录一条路径入VC和出VC号，跨过该路由的每条路径都需要一组VC对应）</li>
</ul>

<p>虚电路中的三个阶段</p>

<ul>
  <li>虚电路建立</li>
  <li>数据传送</li>
  <li>虚电路拆除</li>
</ul>

<p>数据报网络（datagram network）：无连接状态的网络，发送发只负责将含有目标IP地址的datagram包发送给下层输送到网络中即可，不需要先建立维护一条路径，会有路由器自动根据转发表转发到目标地址</p>

<ul>
  <li>转发表前缀（prefix）匹配-<strong>最长前缀匹配原则</strong>（loggest prefix matching rule）：将目标地址和转发表中最长匹配到的前缀做为转发目标，把分组转发到对应的链路</li>
</ul>

<h4 id="43-路由器工作原理">4.3 路由器工作原理</h4>

<p>转发功能（forwarding function）：组成——输入/输出端口（指接收/发送数据的物理接口）、交换结构（将输入与输出相连的内部结构）、路由选择处理器（维护路由选择表以及连接链路状态和更新路由表的处理器）、以及相应的执行路由选择协议，响应输入转发的软件——又可分为路由器转发平面（router forward plane）和路由器控制平面（router control plane）</p>

<blockquote>
  <p>路由器转发平面：管转发的，通常由硬件实现</p>

  <p>路由器控制平面：管路由选择的，通常由软件实现</p>
</blockquote>

<p>输入端口、输出端口（略）</p>

<p>交换结构</p>

<ul>
  <li>
    <p>经内存交换</p>
  </li>
  <li>
    <p>经总线交换</p>
  </li>
  <li>
    <p>经网状结构交换（经互联网络交换）</p>
  </li>
</ul>

<blockquote>
  <p>通过内存切换;通过总线交换;通过互连网络进行交换。</p>

  <p>一个互连网络可以并行转发数据包，只要所有的数据包被转发到不同的输出端口</p>
</blockquote>

<h4 id="44-网际协议ip因特网中的转发和编址">4.4 网际协议（IP）：因特网中的转发和编址</h4>

<p>因特网网络层三大部件：</p>

<ul>
  <li>IP协议（使用无连接的IP协议提供服务，尽力而为的服务，啥都不保证，需要在传输层TCP保证）</li>
  <li>路由选择部分</li>
  <li>网络层差错控制和信息报协议，互联网控制报文协议（ICMP）</li>
</ul>

<p><img src="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,textFFFFFF,t_70" alt="img" /></p>

<h5 id="441-数据报格式ipv4">4.4.1 数据报格式（IPv4）</h5>

<p><img src="../images/watermark,type_ZmFuZ" alt="img" /></p>

<ol>
  <li>
    <p>版本号（IPv4、IPv6）：不同版本对数据报不同解释</p>
  </li>
  <li>
    <p>首部长度：数据报可包含可变数量的选项。不过大部分没有，首部固定20字节</p>
  </li>
  <li>
    <p>服务类型：区分不同类型的IP数据报</p>
  </li>
  <li>
    <p>数据报长度：首部+数据的长度。该字段16bit，然而一般数据报很少超过1500字节</p>
  </li>
  <li>
    <p>标识、标志、片偏移：IP分片相关。不过IPv6不允许在路由器上对分组分片</p>
  </li>
</ol>

<p><img src="../images/image-20230530111257848.png" alt="image-20230530111257848" />
<img src="../images/image-20230530111617466.png" alt="image-20230530111617466" /></p>

<p>==注意片偏移是13位，所以8字节一个块==</p>

<p><strong>注意分片时，如果最后不够八字节，最后余下的几个字节要分到下一个片中</strong></p>

<ol>
  <li>
    <p>寿命TTL（time to live）：确保数据报不会永远在网络中循环。每被一个路由器处理时，值-1。若值减到0，丢弃数据报</p>
  </li>
  <li>
    <p>协议号：到达最终目的地才有用，指示了IP数据报的数据部分应该交给哪个运输层协议。如6交给TCP，如17交给UDP。协议号是将网络层与运输层绑定到一起的粘合剂；端口号是将运输层和应用层绑定的粘合剂</p>
  </li>
  <li>
    <p>首部检验和：帮忙路由器检测收到IP数据报中首部的比特错误，有错一般丢弃。每台路由器上必须重新计算检验和。<strong>IP层仅对IP首部计算检验和</strong>，而TCP/UDP检验和是对整个TCP/UDP报文段进行的。</p>
  </li>
  <li>
    <p>源和目的IP地址：源主机通过DNS查找目的地址</p>
  </li>
  <li>
    <p>选项：IPv6已抛弃选项字段</p>
  </li>
  <li>
    <p>数据（有效载荷）：包含运输层报文段（TCP或UDP），或ICMP报文段</p>
  </li>
</ol>

<p>​	一个IP数据报有长为20的首部，如果数据报承载一个TCP报文段，则每个无分片数据报承载总长40的首部（IP协议的首部，还有TCP的20）以及应用层报文</p>

<p><strong>IP数据报分片</strong></p>

<p><img src="../images/image-20230606164158106.png" alt="image-20230606164158106" /></p>

<blockquote>
  <p>请注意，是IP数据报分成更多的IP数据报，所以x-20/MTU-20</p>
</blockquote>

<p>网络链路存在MTU (最大传输单元)—链路层数据帧可封装数据的上限，不同链路的MTU不同</p>

<p>IPv4的设计者决定把数据报的重新组装工作放在端系统而不是路由器中。</p>

<p>大IP分组向较小MTU链路转发时， 可以被“分片” (fragmented)，是在路由器中被分片</p>

<p>1个IP分组分为多片IP分组，形成的每个数据报（片）具有初始数据报的源地址、目的地址和==标识号==</p>

<p>IP分片到达目的主机后进行“重组”(reassembled)</p>

<p>IP首部的相关字段用于标识分片以及确定分片的相对顺序：总长度、标识、标志位和片偏移</p>

<p>假设原IP分组总长度为L，待转发链路的MTU为M</p>

<p>若L&gt;M，且DF=0，则可以/需要分片</p>

<p>分片时每个分片的标识复制原IP分组的标识</p>

<p>通常分片时，除最后一个分片，其他分片均分为MTU允许的最大分片</p>

<p>最后一个片的标志为0，其余的为1，这是为了让目的主机相信它收到了初始数据报的最后一个片</p>

<p><img src="../images/52733a654d27413fbe817a7e338275cd.png" alt="在这里插入图片描述" /></p>

<h5 id="442-ipv4-编址">4.4.2 IPv4 编址</h5>

<p>主机与物理链路的边界叫接口(interface)，一台路由器有多个接口， 一个 IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联。通常用点分十进制记法书写。</p>

<p>IP地址包括两部分，网络号(NetID) 和主机号(HostID)，具有相同网络号的设备接口组成子网，可以彼此物理联通，不跨越路由器（第三及以上层网络设备）IP编址为这个子网分配一个地址：223.1.1.0/24，/24记法称为子网掩码。</p>

<p><strong>分类编制</strong></p>

<p><img src="../images/watermark,type_ZmFuZ3poZW5naGVpdG,size_16,color_FFFFFF,t_70" alt="请添加图片描述" /></p>

<p>A类：$2^{24}-2$</p>

<p>B类：$2^{16}-2=65534$</p>

<p>C类：$2^8-2=254$</p>

<p><strong>1. 获取一块地址</strong></p>

<ul>
  <li>
    <p>子网获取IP地址：由ISP从它大块地址中分配</p>
  </li>
  <li>
    <p>ISP获取IP地址：IP地址由因特网名字和编号分配机构ICANN管理（也管理DNS根服务器、AS标识号）。ICANN向区域性因特网注册机构分配地址，处理本地域内的地址分配/管理。</p>
  </li>
</ul>

<p>因特网地址分配策略：<strong>无类别域间路由选择</strong> (Classless Interdomain Routing，CIDR) ，a.b.c.d/x的地址的x最高比特构成IP地址的网络部分，称为该地址的前缀，一个组织通常被分配一块连续的地址，即具有相同前缀的一段地址。</p>

<p><strong>地址聚合（路由聚合）</strong>：使用单个网络前缀通告多个网络的能力</p>

<h6 id="2-获取主机地址动态主机配置协议">2. 获取主机地址：动态主机配置协议</h6>

<p>动态主机配置协议（Dynamic Host Configuration，DHCP）允许主机自动获取（被分配）一个 IP 地址。网络管理员能够配置 DHCP，以使某给定主机每次与网络连接时能得到一个相同的 IP 地址，或者某主机将被分配一个临时的 IP 地址（tempomry IP address ），每次与网络连接时该地址也许是不同的。 除了主机 IP 地址分配外，DHCP 还允许一台主机得知其他信息，例如它的子网掩码、它的第一跳路由器地址（常称为默认网关）与它的本地DNS 服务器的地址。</p>

<p>DHCP是<strong>插即用协议</strong>，DHCP是一个客户-服务器协议。</p>

<p><img src="../images/123" alt="img" />
新主机到来时，DHCP协议的四个步骤</p>

<ul>
  <li>1.DHCP服务器发现</li>
</ul>

<p>​	新到的客户通过广播DHCP发现报文，发现一个要与其交互的DHCP服务器
客户在UDP分组中向端口67发送该发现报文，此时必须用广播地址255.255.255.255，源地址是0.0.0.0</p>

<ul>
  <li>2.DHCP服务器提供</li>
</ul>

<p>​	DHCP收到DHCP发现报文后，响应一个DHCP提供报文，仍然使用广播地址255.255.255.255，因为此时新客户并没有IP地址
​	可能有多台DHCP服务器，每台服务器提供的报文中，有向客户主机推荐的IP地址、网络掩码以及IP地址租用期（一般几天或几小时）</p>

<ul>
  <li>3.DHCP请求</li>
</ul>

<p>​	客户从提供中选一个，向选中的服务器提供一个DHCP请求报文进行响应，回显配置参数</p>

<ul>
  <li>4.DHCP ACK</li>
</ul>

<p>​	收到DHCP请求报文后，用DHCP ACK报文对其记性响应，证实所传参数</p>

<p>客户收到ACK后，交互完成，在租期内使用DHCP分配的IP地址。DHCP提供了机制允许客户更新对一个IP地址的租用</p>

<p>当一个移动结点在子网之间移动时，就不能维持与远程应用的TCP连接。</p>

<h6 id="3-网络地址转换nat">3. 网络地址转换（NAT）</h6>

<p><strong>NAT使能路由器</strong></p>

<p>​	NAT路由器对外界来看像一个具有单一IP地址的单一设备。例如，家里有一个NAT使能路由器，其IP地址138.76.29.7，且进入和离开家庭的报文都有同样的该地址</p>

<p>​	NAT路由器对外隐藏了家庭网络的细节</p>

<p>​	NAT路由器从ISP的DHCP服务器得到它的地址，并且路由器运行一个DHCP服务器，为位于NAT-DHCP路由器控制的家庭网络地址空间中的主机提供地址</p>

<p><img src="../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tNzZG4ubmV0L2hhcHB5amFjb2I=,size_16,color_FFFFFF,t_70" alt="img" /></p>

<p>注意：NAT路由器将LAN端端口号改成5001时，5001是NAT转换表中没有的任意一个都可以</p>

<p>NAT重要问题：</p>

<ul>
  <li>
    <p>端口号是用来进程编制的，而不是主机编址的</p>
  </li>
  <li>路由器应该只处理3层功能</li>
  <li>违背端到端通信原则，应用开发者必须考虑到NAT的存在</li>
  <li>地址短缺问题应该由IPv6来解决</li>
</ul>

<p>妨碍P2P应用程序，包括P2P共享和语音。一个对等方在NAT后面，不能充当服务器并接受TCP连接，其解决办法是连接反转</p>

<p>连接反转：A通过C与B联系，C不位于NAT之后并与B建立了TCP连接，已经被很多P2P应用用于NAT穿越</p>

<p>若对等方A和B都在NAT之后，使用应用程序进行中继处理，如Skype中继</p>

<h5 id="443-因特网控制报文协议icmp">4.4.3 因特网控制报文协议ICMP</h5>

<p>ICMP被主机和路由器用来沟通网络层信息，如差错报告</p>

<p>​        如『目的网络不可到达』这种错误是在ICMP产生的，IP路由器找不到路径通往指定主机，该路由器就向发送主机发出ICMP报文指示错误</p>

<p>​    ICMP通常被认为是IP的一部分，但从体系结构上来讲它是位于IP之上的，因为ICMP报文是承载在IP分组中的。也就是说，ICMP报文是作为IP有效载荷承载的。</p>

<p>​    ping：发送一个ICMP类型8编码0（回显请求）的报文到指定主机，目的主机发回一个类型0编码0（回显回答）的报文</p>

<p>​    源抑制报文：拥塞的路由器向主机发送，强制主机减小发送速率。TCP在运输层有拥塞控制机制，不需要该报文的信息了</p>

<p>​    Traceroute：如何跟踪从一台主机到世界上任意一台主机之间的路由？</p>

<p>​        原理：IP协议规定，路由器收到TTL为0的数据报会将其丢弃，然后发送一个ICMP告警报文给源主机，which concludes the name and IP address of it</p>

<p>​        方法：发送TTL为1~n的一系列IP数据报。当到达目的主机时，返回一个端口不可达（数据报携带了不可达UDP端口号）的ICMP报文，则结束探测</p>

<h5 id="444-ipv6">4.4.4 IPv6</h5>

<p>IPv6是由八组，每组四位16进制数字组成，每组之间由”：”来分隔。</p>

<p><img src="../images/5684" alt="img" /></p>

<p>IPv6字段</p>

<ul>
  <li>
    <p>版本号(version)
    不同的IP协议版本使用不同的数据报格式。</p>
  </li>
  <li>
    <p>通信量等级(Traffic Classes)
    使得源节点和路由器能够识别IPv6信息包的优先级。与IPv4服务类型TOS字段含义类似。</p>
  </li>
  <li>
    <p>流标签(Flow Label)
    标记那些需要IPv6路由器特殊处理(如一种非默认服务质量或实时服务)的信息包顺序。</p>
  </li>
  <li>
    <p>有效负载长度(Payload Length)
    定长40字节数据报首部后面的字节数量，包括扩展报头和负载数据，即数据报长度-40。</p>
  </li>
  <li>
    <p>下一个首部(Next Header)
    当IPv6没有扩展报头时，该字段的作用和IPv4的上层协议字段一样。当含有扩展报头时，该字段的值即为第一个扩展报头的类型。</p>
  </li>
  <li>
    <p>跳限制(Hop Limit)
    转发数据报的每台路由器对该字段的值减1，若减为0则丢弃该数据报。</p>
  </li>
  <li>
    <p>源和目的IP地址(Source/Destination Address)</p>
  </li>
  <li>
    <p>数据(Data)
    当数据报到达目的地时，该有效载荷就从IP数据报移出，并交给下一个首部字段中指定的协议。</p>
  </li>
  <li>
    <p>源和目的IP地址(Source/Destination Address)</p>
  </li>
</ul>

<p><strong>2. IPv4到IPv6的迁移</strong></p>

<p>​    <strong>双栈</strong>：同时使用IPv4和IPv6，这种结点有两种地址。DNS可解析两种地址。如果发送方和接收方中任意一个仅为IPV4使能的，则必须使用IPv4数据报。</p>

<blockquote>
  <p>注意：结点B必须生成一个IPv4数据报发给C，IPv6数据报的数据字段可以复制到IPv4数据报的数据字段中，并且要做适当的映射。在IPv4中没有对应的部分的数据，这些字段的信息会丢失（比如流标签）</p>
</blockquote>

<p><strong>建隧道：</strong>图中B和E，要使用IPV6交互，但是它们经由中间IPv4路由器关联的，我们将两台IPv6路由器之间的Ipv4路由器的集合成为一个<strong>隧道</strong>，将整个IPv6数据报放在IPv4的有效载荷中。</p>

<h5 id="445-涉足ip安全性">4.4.5 涉足IP安全性</h5>
<p>​    新型网络层协议：IPsec（如果你是Mac OS，网络设置中添加VPN服务时你会看到）。与IPv4和IPv6向后兼容
​        在VPN（虚拟专用网）中部署
​        两台主机要通信，IPsec只需在两台主机中可用，其他主机和路由器继续用普通的IPv4
​        两台主机首先创建IPsec会话（面向连接的），在两台主机发送的TCP和UDP报文段都享受IPsec的安全性服务</p>

<p>密码技术约定</p>

<ul>
  <li>
    <p>IP数据报有效载荷的加密</p>
  </li>
  <li>
    <p>数据完整性</p>
  </li>
  <li>
    <p>初始鉴别</p>

    <p>主机确信在数据报中的源IP地址是该数据报的实际源。常见端口号查询</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>21:FTP文件传输协议（控制）
22：SSH远程登陆协议
23：telnet
25:SMTP，用于发送文件
53:DNS域名服务器
80:http协议
</code></pre></div></div>

<h4 id="45-路由选择协议">4.5 路由选择协议</h4>

<p>路由选择：确定从发送方到接收方通过路由器网络的好路径</p>

<p>主机通常直接与一台路由器相连，该路由器即为该主机的<strong>默认路由器</strong>或<strong>第一跳路由器</strong></p>

<p>源主机默认路由器称为源路由器，目的主机默认路由器称为目的路由器</p>

<p>一个分组从源主机到目的主机 == 从源路由器到目的路由器</p>

<p>路由选择算法：给定一组路由器和连接路由器的链路，路由选择算法找到一条源路由器到目的路由器好的路径（最低费用），如最短路径算法（图）</p>

<p>第一种分类方法：</p>

<ul>
  <li>全局式路由选择算法
用完整、全局性的网络信息计算出最短路径（最低费用路径）
practically具有全局状态信息的算法称作链路状态算法（LS）</li>
  <li>分散式路由选择算法
迭代、分布式的方式计算最短路径
没有结点拥有关于网络链路的完整信息，每个结点仅有与其直接相连链路的信息即可工作
通过迭代计算并与相邻结点交换信息，逐渐计算出最低费用路径，距离向量算法（DV）</li>
</ul>

<p>第二种分类方法：</p>

<ul>
  <li>静态路由选择算法
  变化缓慢，通常人工干预</li>
  <li>动态路由选择算法
  网络流量负载或拓扑发生变化时改变路由选择路径
  周期性运行或直接响应变化
  也容易受路由选择循环、路由震荡等问题的影响</li>
</ul>

<p>第三种分类方法：</p>

<ul>
  <li>负载敏感算法
    链路费用动态变化来反映链路拥塞水平</li>
  <li>负载迟钝算法
    链路费用与拥塞无关，当今因特网路由选择算法基本都是迟钝的</li>
</ul>

<h5 id="451-链路状态路由选择算法ls">4.5.1 链路状态路由选择算法LS</h5>
<p>网络拓扑和所有链路费用已知。实践中是由每个节点向网络其他所有节点广播链路状态分组完成的，例如OSPF路由选择协议由链路状态广播算法完成</p>

<p>所有节点都具有该网络的信息，每个节点运行LS算法</p>

<p>Dijkstra算法
会产生路由震荡，可以让每台路由器发送链路通告的时间随机化</p>

<h5 id="452-距离向量路由算法dv">4.5.2 距离向量路由算法DV</h5>
<p>迭代、异步、分布式</p>

<p>分布式：每个结点要从一个或多个直接相连邻居接收某些信息，计算，将计算结果发给邻居</p>

<p>迭代：过程持续到邻居之间无更多信息交换</p>

<p>异步：不要求所有节点相互步伐一致操作</p>

<p>DV算法</p>

<p>Bellman-Ford方程</p>

<p>无更新报文发送，不会出现进一步路由选择表计算，算法进入静止状态。直到一条链路费用发生改变</p>

<p>链路费用改变与链路故障</p>

<p>路由选择环路，无穷计数问题</p>

<p>增加毒性逆转
欺骗费用无穷大。如果z通过y路由选择到目的地x，则z通告y，它（z）到x的距离是无限大。
只能解决两个直接相连无穷计数问题，更多结点环路无法解决</p>

<p>LS与DV路由选择算法的比较</p>

<ul>
  <li>报文复杂性</li>
</ul>

<p>​	显然LS复杂得多，每条链路费用改变都要通知所有结点</p>

<ul>
  <li>收敛速度</li>
</ul>

<p>​	DV算法收敛较慢，且会遇到路由选择环路和无穷计数问题</p>

<ul>
  <li>健壮性</li>
</ul>

<p>​	路由器发生故障，LS结点仅计算自己的转发表，提供了一定健壮性</p>

<p>​	DV算法一个 不正确的结点会扩散到整个网络</p>

<p>其他路由选择算法</p>

<p>LS、DV基本上是当前因特网实践中使用的仅有的两种路由选择算法</p>

<p>很多种新型算法，一种是基于将分组流量看做网络中源和目的之间的流</p>

<p>电路交换路由选择算法也有参考价值</p>

<h5 id="453-层次路由选择">4.5.3 层次路由选择</h5>
<p>问题</p>

<ul>
  <li>
    <p>规模。当路由器数目变得很大，算法开销高的不可实现如LS更新链路费用</p>
  </li>
  <li>
    <p>管理自治。一个组织希望按自己愿望运行管理其网络</p>
  </li>
</ul>

<p>解决方法：将路由器组织进自治系统AS（autonomous system）</p>

<p>每个AS由一组处在相同管理控制下的路由器组成（如相同的ISP运营）</p>

<p>相同AS中路由器全部运行同样的路由选择算法，叫做自治系统内部路由选择协议（intra_autonomous system routing protocol）</p>

<p>一个AS内一台或多台路由器负责向本AS之外的目的地转发分组，这些路由器称为<strong>网关路由器</strong>，当有多台网关路由器，需要用到自制系统间路由选择协议来配置转发表</p>

<p>因特网中所有AS中都运行相同的AS间路由选择协议BGP4</p>

<p>每台路由器接收来自一个AS内部路由选择协议和一个AS间路由选择协议的信息，并使用来自这两个协议的信息配置它的转发表。</p>

<p>某AS非网关路由器对转发表增加用于子网x（该AS外）的表项采取的动作：</p>

<ul>
  <li>
    <p>从AS间协议知道经多个网关可达子网x</p>
  </li>
  <li>
    <p>使用AS内部协议的路由选择信息，决定到每个网关的最低费用路径的费用</p>
  </li>
  <li>
    <p><strong>热土豆路由选择</strong>：选择具有最小的最低费用的网关</p>
  </li>
</ul>

<blockquote>
  <p>假定，AS1可以通过子网AS2或子网AS3到达目的子网x，那么从源路由器1d中会选择，具有最小的最低费用的网关，它将数据包发送给最近的下一跳，而不是等待最佳路径。这种协议可以在网络拓扑结构变化频繁的情况下提供更快的路由重定向，并减少网络拥塞和延迟。</p>
</blockquote>

<ul>
  <li>
    <p>从转发表确定最低费用网关接口I，将（x,I）添加到转发表中</p>
  </li>
  <li>
    <p>如果AS从一个相邻AS处知道一个目的地，该AS能向它某些其他相邻AS通告该路由选择信息</p>
  </li>
  <li>
    <p>一个ISP可能分为多个互联的AS</p>
  </li>
</ul>

<h4 id="46-因特网中的路由选择">4.6 因特网中的路由选择</h4>

<p>AS<strong>内部路由协议</strong>也称为内部网络协议(interior gateway protocols，IGP)</p>

<p>最常见的AS内部路由协议：</p>

<ul>
  <li>
    <p>路由信息协议：RIP(Routing Information Protocol)</p>
  </li>
  <li>
    <p>开放最短路径优先：OSPF(Open Shortest Path First)</p>
  </li>
  <li>
    <p>内部网关路由协议：IGRP(Interior Gateway Routing Protocol)</p>
  </li>
  <li>
    <p>Cisco私有协议</p>
  </li>
</ul>

<h5 id="461-ripdv思想路由信息协议">4.6.1 RIP（DV思想）路由信息协议</h5>

<p>RIP协议是最先得到广泛使用的一种路由协议，配置简单。是一种基于距离矢量算法的协议，它使用跳数作为度量来衡量到达目的网络的距离。RIP通过UDP报文进行路由信息的交换，使用的端口号为520。</p>

<p>RIP协议要求网络中每一台路由器都要维护从自身到每一个网络的路由信息。RIP协议使用跳数来衡量网络间的“距离”：从一台路由器到其直连网络的跳数定义为1；从一台路由器到其非直连网络的距离定义为：每经过一个路由器则距离加1。“距离”也称为跳数，RIP允许的最大跳数为15，当延伸到16时，即视为不可达。所以RIP一般只适用于小型网络。</p>

<h5 id="462-ospfls思想开放最短路径优先">4.6.2 OSPF（LS思想）开放最短路径优先</h5>

<p>OSPF和其兄弟IS-IS通常设置在上层ISP中，RIP在下层ISP和企业网中。</p>

<p>OSPF是一种链路状态协议，它使用洪泛链路状态信息和Dijkstra最低开销路径算法。<strong>使用OSPF,—台路由器构建了一幅关于整个自治系统的完整拓扑图</strong></p>

<p>使用OSPF时，路由器向自治系统内所有其他路由器广播路由选择信息，每当一条链路的状态发生变化时（如开销的变化或连接/中断状态的变化），路由器就会广播链路状态信息。即使链路状态未发生变化，它也要周期性地（至少每隔30min-次）广播链路状态。</p>

<h5 id="463-bgpisp-之间的路由选择border-gateway-protocol-边界网关协议">4.6.3 BGP（ISP 之间的路由选择）(Border Gateway Protocol) （边界网关协议）</h5>

<p>BGP协议是用于自治系统AS之间的动态路由协议。BGP是一种外部网关协议，与OSPF、RIP等内部网关协议不同，其着眼点不在于发现和计算路由，而是着眼于在AS之间控制路由的转播和选择最佳路由。BGP将Internet “粘合”为一个整体。</p>

<p>在BGP 中，目的地不是主机而是CDIR化的前缀</p>

<p>跨越两个AS的BGP连接称为外部BGP（eBGP）连接，而在相同AS中的两台路由器之间的BGP会话称为内部BGP（iBGP）连接。</p>

<p><img src="../images/asfasgag.png" alt="img" /></p>

<p>BGP：边界网关协议，跨越多个AS的源和目的对之间确定路径，现在用的BGP4</p>

<p>BGP为AS提供：</p>

<ul>
  <li>
    <p>从相邻AS获得子网可达性信息</p>
  </li>
  <li>
    <p>向本AS内部所有路由器传播这些可达性信息</p>
  </li>
  <li>
    <p>基于可达性信息和AS策略，决定到达子网的路由</p>
  </li>
</ul>

<p>​    BGP使得每个子网向因特网其余部分通告它的存在：一个子网高声宣布『在这！』，并且确保因特网中所有AS知道该子网以及如何到达</p>

<p><strong>2.路径属性和BGP路由</strong></p>

<p>带有属性的前缀被称为一条路由</p>

<p>前缀：CDIR化的前缀</p>

<ul>
  <li>AS-PATH</li>
  <li>NEXT-HOP</li>
</ul>

<h3 id="第五章链路层">第五章、链路层</h3>

<h4 id="51-链路层概述">5.1 链路层概述</h4>

<p>运行链路层协议的任何设备均称为<strong>结点</strong>，沿着通信路径连接相邻结点的通信信道称为<strong>链路</strong>。通过特定链路时，传输结点将数据报封装在链路层帧中，将该<strong>帧</strong>传入链路。</p>

<ul>
  <li>
    <p>节点（node）：能运行链路层协议的任何设备（如主机、路由器、交换机、WiFi接入点）</p>
  </li>
  <li>
    <p>链路（link）：沿通信路径连接两个节点的通信信道</p>
  </li>
  <li>
    <p>链路层帧（frame）：在链路层封装的包</p>
  </li>
</ul>

<h5 id="511-链路层提供的服务">5.1.1 链路层提供的服务</h5>

<ul>
  <li>
    <p>成帧（framing）：提供将上层数据添加相关标准封装的功能</p>
  </li>
  <li>
    <p>链路接入：媒体访问控制协议（Medium Access Control，MAC）协议：规定帧在链路上的传输规则</p>
  </li>
  <li>
    <p>可靠交付</p>
  </li>
  <li>
    <p>差错检验和纠正技术</p>
  </li>
</ul>

<h5 id="512-链路层在何处实现">5.1.2 链路层在何处实现</h5>

<p>链路层主体在网络适配器（network adapter）也叫网络接口（network Interface Card NIC）上实现，其核心是链路层控制器，实现了许多链路层服务（成帧、链路层接入、差错检测）的专用芯片</p>

<p>大部分链路层是在<strong>硬件</strong>中实现的，但部分链路层是在运行于主机CPU上的软件中实现的，软件实现了高级功能，如组装链路层寻址信息和激活控制器硬件，响应控制器中断</p>

<p><strong>链路层是协议栈中软件和硬件交接的地方</strong></p>

<h4 id="52-差错检测和纠正技术">5.2 差错检测和纠正技术</h4>

<p><strong>比特级差错检测与纠正</strong>，即对从一个结点发送到另一个物理上连接的邻近结点的链路层帧中的比特损伤进行检测与纠正，它们通常是链路层提供的两种服务。</p>

<p>为了保护比特免受差错，使用<strong>差错检测和纠正比特（EDC）</strong>。通常，要保护的数据不仅包括从网络层传递下来需要通过链路传输的数据报，而且包括链路帧首部中的链路级的寻址信息、序号和其它字段。</p>

<p>即使采用差错检验比特，也还是可能有未检出比特差错。</p>

<h5 id="521-奇偶校验">5.2.1 奇偶校验</h5>

<p>在偶校验方案中，发送方增加一个比特，使得这d+1比特中1的总数是偶数。
对于奇校验方案，发送方增加一个比特，使得这d+1比特中1的总数是奇数。</p>

<ul>
  <li>1 比特校验位
检测奇数位差错</li>
</ul>

<p>二维奇偶校验：</p>

<ul>
  <li>检测奇数位差错、部分偶数位差错</li>
  <li>纠正同一行/列的奇数位错</li>
</ul>

<h5 id="522-校验和方法">5.2.2 校验和方法</h5>

<p>加反，加判，溢出回卷</p>

<p>加反：求校验和时的操作</p>

<p>加判：接收方检验数据时的操作</p>

<p>UDP校验和是检测满足累加和为0xffff</p>

<h5 id="523-循环冗余检测">5.2.3 循环冗余检测</h5>

<p>发送发送d+r，和 G ，</p>

<p>G是生成多项式，r：CRC 比特</p>

<p>R = remainder $\frac{D·2^r}{G}$</p>

<h4 id="53-多路访问链路和协议">5.3 多路访问链路和协议</h4>

<p>有两种类型的网络链路</p>

<ul>
  <li>点对点链路</li>
</ul>

<p>点对点协议PPP</p>

<p>高级数据链路控制协议HDLC</p>

<ul>
  <li>广播链路</li>
</ul>

<p>让多个发送和接收结点都连接到相同的、单一的、共享的广播信道上</p>

<p>当任何一个结点传输一个帧时，信道广播该帧，其他结点都收到一个副本</p>

<p>如以太网和无线局域网</p>

<p>多路访问协议：结点通过协议规范它们在共享的广播信道上的传输行为</p>

<ul>
  <li>
    <p>信道划分协议</p>
  </li>
  <li>
    <p>随机接入协议</p>
  </li>
  <li>
    <p>轮流协议</p>
  </li>
</ul>

<p>协议希望有的特性，理想情况下对速率R bps的广播信道</p>

<ol>
  <li>
    <p>仅有一个结点发送数据，结点具有R bps的吞吐量</p>
  </li>
  <li>
    <p>M个结点发送数据时，每个结点平均吞吐量R/M bps</p>
  </li>
  <li>
    <p>协议分散，不会因为主结点故障似整个系统崩溃</p>
  </li>
  <li>
    <p>协议简单不昂贵</p>
  </li>
</ol>

<h5 id="531-信道划分协议">5.3.1 信道划分协议</h5>

<ul>
  <li>TDM(时分多路复用)</li>
</ul>

<p>TDM把时间划分为时间帧,并进一步把时间帧划分为N个时隙(slot).(时间帧和链路层交换的单元帧不是一个意思)
然后把每个时隙分给N个节点中的一个.无论何时某个节点在有分组想要发送的时候,他在循环的TDM帧中指派给它的时隙内传输分组比特.时隙长度一般应是一个时隙内能传输一个分组</p>

<p>TDM的缺点</p>
<ol>
  <li>最高速率只能达到R/N bps ,即使只有一个人使用信道</li>
  <li>
    <p>节点总是总是要等待它的时隙,可能会对缓存等造成压力</p>
  </li>
  <li>消除了碰撞且十分公平</li>
</ol>

<ul>
  <li>FDM(频分多路复用)</li>
</ul>

<p>FDM将Rbps的信道划分为不同的频段(每个频段具有R/N带宽),并把每个频段分给N个结点中的一个.因此FDM在1个较大的信道中创建了N个较小的R/N信道.</p>

<p>FDM的缺点和TDM相同,限制了每个结点只能使用R/N带宽..</p>

<ul>
  <li>码分多址CDMA（Code Division Multiple Access）</li>
</ul>

<p>TDM和FDM分别为结点分配时隙和频率，CDMA对每个结点分配不同的编码</p>

<p>每个结点用其唯一编码对发送数据进行编码，使得不同结点能同时传输，接收方仍能正确而接收</p>

<p>抗干扰，军用系统，民用蜂窝电话</p>

<h5 id="532-随机接入协议">5.3.2 随机接入协议</h5>

<p>传输结点总是以信道全部速率R bps进行发送</p>

<p>有碰撞时，涉及碰撞的每个节点反复重发它的帧（等待一个随机时延），直到该帧无碰撞的通过</p>

<p>常用随机接入协议：</p>

<ul>
  <li>1.时隙ALOHA</li>
</ul>

<p>当结点有新帧发送时，等到下一个时隙开始传输整个帧（设一个时隙传一个帧）。时隙开始时传输。</p>

<p>如果有碰撞，结点在时隙结束之前检测到这次碰撞，以p的概率在后序的每个时隙重传它的帧，直到无碰撞。</p>

<p>时隙ALOHA==需要在结点中对时隙同步==。刚好有一个结点传输的时隙称为一个成功时隙。时隙多路访问协议的效率定义为：当有大量的活跃结点且每个结点总有大量的帧要发送时，长期运行中成功时隙的份额。</p>

<p>效率：当活跃结点数量趋向无穷大时，最大效率1/e，即37%。一个给定的结点成功传送的概率是$p(1-p)^{n-1}$,因为有N个结点，任意一个结点成功传送的概率是$Np(1-p)^{n-1}$。</p>

<ul>
  <li>2.（纯）ALOHA</li>
</ul>

<p>碰撞时，立即以概率p重传该帧，否则等待一个帧传输时间</p>

<p>效率：仅为时隙ALOHA的一半$\frac1{2e}$：.一个给定结点成功传输一次的该概率是$p(1-p)^{2(n-1)}$</p>

<ul>
  <li>
    <ol>
      <li>载波侦听多路访问（CSMA）</li>
    </ol>
  </li>
</ul>

<p>在时隙和纯ALOHA种，一个结点传输的决定独立于其他结点，不关心自己传输时别人是不是在传输
举例：有礼貌的人类谈话有两个重要规则</p>

<p>说话之前先听。如果在说话，等他们说完话再说，网络中称为==载波侦听==，结点等待直到一小段时间没有传输，然后开始传输</p>

<p>如果与他人同时开始说话，停止说话。称为碰撞检测，当一个传输结点在传输时一直侦听此信道，如果检测到另一个结点正在传输，它就停止，等待一段随机事件，重复『侦听=当空闲时传输』动作</p>

<p>这两个规则包含在CSMA和具有碰撞检测的CSMA/CD协议族中</p>

<p>所有结点都载波侦听了，为何当初会发生碰撞？</p>

<p>B的比特沿着广播媒体传播所实际需要的时间不是0（即使2*10^8），在还没到D时，尽管B正在发，但D侦听的信道空闲，D就开始传输，于是发生了碰撞</p>

<p>广播信道端到端信道传播时延决定了性能，时延越大，不能侦听到已传输结点的可能就越大，碰撞越多，性能越差</p>

<p>二进制指数后退算法</p>

<p>当该帧经历了一连串的n次碰撞之后，节点随机地从 {0，1，2，…，$2^n-1$} 中选择一个给定的K值，因此一个帧经历的碰撞越多，K选择的间隔越大</p>

<p>效率：$\frac{1}{1+5d_{prop}/d_{trans}}$    d（prop）是信号能量在任意连个适配器之间传播所需的最大时间，d（trans）是指传输一个最大长度的以太网帧的时间</p>

<h5 id="533-轮流协议">5.3.3 轮流协议</h5>

<ul>
  <li>轮询协议</li>
</ul>

<p>指定一个主结点，以循环的方式轮询每个结点</p>

<p>主结点首先向结点A发送一个报文，告知A能传输帧的最大数量，A传完后主结点告诉B能传帧的最多数量，如此循环</p>

<p>缺点：有轮询时延；主结点故障，整个信道就GG</p>

<ul>
  <li>令牌传递协议</li>
</ul>

<p>没有主结点，一个叫令牌token的特殊帧在结点之间以固定次序交换，如1发给2，2发给3，N发给1，就像网络拓扑结构中的环状网络令牌</p>

<p>当一个结点收到令牌时，有帧发送，则发送最大数量的帧，然后转发令牌；没帧发送，直接把令牌转发.</p>

<p>缺点：单点故障。</p>

<p>DOCISIS：用于电缆因特网接入的链路层协议</p>

<h4 id="54-交换局域网">5.4 交换局域网</h4>

<ol>
  <li><strong>MAC地址</strong></li>
</ol>

<p>并不是主机或路由器具有链路层地址，而是它们的适配器（网络接口）具有链路层地址。具有多个网络接口的主机或路由器也有多个链路层地址，就像它也有多个IP地址一样。</p>

<p>MAC地址(或称LAN地址，物理地址，以太网地址) 用于局域网内标识一个帧从哪个接口发出，到达哪个物理相连的其他接口。</p>

<p><strong>MAC地址48位</strong>，（6个十六进制数对）通常用十六进制表示法，如1A-2F-BB-76-09-AD。MAC地址固化在网卡的ROM中，有时也可以软件设置。</p>

<p>没有两块适配器有相同的MAC地址，MAC地址空间由IEEE管理，IEEE给公司固定前24个比特，后面24个比特让公司自己去生成。</p>

<p>MAC地址具有扁平接口。比如具有802.11接口的手机总是有相同mac地址，而当主机移动时，IP地址会改变（IP地址是层次结构）。<strong>MAC地址像身份证号，不会因为位置改变法生改变；IP地址像邮政地址，会改变</strong></p>

<ol>
  <li><strong>地址解析协议ARP（即插即用的）</strong></li>
</ol>

<p>作用：实现IP地址和MAC地址的转换</p>

<p><strong>DNS为因特网中任何地方的主机解析主机名，而ARP只为在同一个子网上的主机和路由器接口解析IP地址。</strong>每台主机和路由器在内存中有一个ARP表，存储某些LAN结点的IP/MAC地址映射关系：&lt; IP地址; MAC地址; TTL&gt;</p>

<p>TTL为过期时间（典型值为20分钟）</p>

<p>A广播ARP查询分组，其中包含B的IP地址，
目的MAC地址 = FF-FF-FF-FF-FF-FF，LAN中所有结点都会接收ARP查询
B接收ARP查询分组，IP地址匹配成功，利用单播帧向A应答B的MAC地址
A在其ARP表中，缓存B的IP-MAC地址对，直至超时
ARP是“即插即用”协议，结点自主创建ARP表，无需干预</p>
