<h3 id="奇偶校验码只能检查奇数个错误"><a href="https://so.csdn.net/so/search?q=奇偶校验码&amp;spm=1001.2101.3001.7020">奇偶校验码</a>（只能检查奇数个错误！！！）</h3>

<p>原理就是：在数据码的首位或者末尾加上一个校验码，分别采用奇校验或者偶校验。加入传输的数据是010110，校验码加首位的话</p>

<p>奇校验：为了使整个码的1的个数是==奇数位==，故首位加$\quad 0:0010110$，计算机传输过去出现一位错误的话，那么就是说1的个数变成偶数个，通过按位异或就会发现结果是0，错误重发。</p>

<p>偶校验：为了使整个码的1的个数是==偶数位==，故首位加$\quad 1:1010110$，奇数个错误的话计算机按位异或每个数就会发现1的个数变成奇数个。异或之后结果为1，cpu发送指令重新发送。</p>

<blockquote>
  <p>总结，奇校验：加上校验码，有奇数个1，那么按位加运算后，0表示错误了，偶校验同理</p>
</blockquote>

<h3 id="校验码的位置">校验码的位置</h3>

<p>这是规定，记住它，在采用汉明码的一串数据中，2的n次方的位置上，我们放校验码。</p>

<p><img src="../images/70" alt="20181019185902376 (1153×373)" /></p>

<h3 id="汉明码是怎么分组的">汉明码是怎么分组的</h3>
<p>把表示位置的这个数，转化成二进制数。</p>

<p>也就是，</p>

<p>第1个位置，变成第0001个位置；</p>

<p>第2个位置，变成第0010个位置；</p>

<p>第3个位置，变成第0011个位置；</p>

<p>第4个位置，变成第0100个位置；</p>

<p>第5个位置，变成第0101个位置；</p>

<p>第6个位置，变成第0110个位置；</p>

<p>那么，规定来了，</p>

<p>凡是位置符合这种形式的，XXX1，归到P1；</p>

<p>凡是位置符合这种形式的，XX1X，归到P2；</p>

<p>凡是位置符合这种形式的，X1XX，归到P3；</p>

<p>凡是位置符合这种形式的，1XXX，归到P4；</p>

<p>那么显然各个校验码也被分到各个组里面去了，而且，==每个组只有一个校验码==。</p>

<p>那么组分好了，校验码的值也就确定下来了。（数组内有多少个1就可以了）</p>

<p>根据配偶或配奇原则来确定汉明码的值。奇校验和偶校验！</p>

<h3 id="重要关系式">重要关系式</h3>

<p>信息位 $m:bit$</p>

<p>校验位 $r:bit$</p>

<p>码字 $n=(m+r):bit$
\(2^r\ge m+r+1=n+1\)
r个校检位</p>

<p>产生r个监督关系式</p>

<p>得到r个校正因子</p>

<p>把P从大到小排列起来，得到一串1010，</p>

<p>for example:</p>

<p>组别：        P5   P4   P3   P2   P1</p>

<p>标志：         1      0      1     0     1</p>

<p>从==大到小排列==起来，标志排成了一串一零串。这个数就是出错的数据的位置。
本例中，10101位置上的位错了，换成十进制是第21个位置上的数错了。</p>

<p>然后，我们发现了它错误的位置，又因为它是二进制的，不是0就是1，所以，可以顺便把它纠错。</p>

<p>注意：在大小端储存中，码字的顺序不同，</p>

<p>==即，从大到小排列之后得到的二进制转化为十进制后的数字，数海明码出错位置时，要从校检位的小到大的排列顺序数。==</p>
